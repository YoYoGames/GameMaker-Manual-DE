<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Accessors</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining the different Accessors" />
  <meta name="rh-index-keywords" content="Accessors" />
  <meta name="search-keywords" content="Accessors,@,[| ],[@ ],[# ],[? ],grid accessor,list accessor,map accessor,array accessor" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Accessors</h1>
  <p>Die <span class="notranslate">GameMaker Language</span> (<span class="notranslate">GML</span>) erlaubt Ihnen auch den Zugriff auf bestimmte <a href="../GML_Reference/Data_Structures/Data_Structures.htm">Datenstrukturen</a> und <a href="Arrays.htm">Arrays</a> durch die Verwendung von logischen Ausdrücken, den so genannten <b>Accessoren</b>. Dies ist ähnlich aufgebaut wie bei der normalen Arbeit mit einem Array, nur dass wir ein <em>Bezeichnersymbol</em> vor dem ersten <span class="notranslate">argument</span> verwenden, um <span data-keyref="GameMaker Name">GameMaker</span> mitzuteilen, dass Sie mit einer (zuvor erstellten) Datenstruktur oder dem Array-Literal arbeiten.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#">DS-Listen [| ]</a></p>
  <div class="droptext" data-targetname="drop-down10">
    <p class="dropspot">Die <span class="notranslate">syntax</span> für <a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">DS-Listen</a> ist:</p>
    <p class="code">list_index[| index]</p>
    <p class="dropspot">Wenn Sie also <span class="inline">ds_list_create()</span> verwendet haben, um Ihre Liste zu erstellen, würden Sie den Listenindex (den Sie in einer Variablen gespeichert haben) verwenden, um darauf zu verweisen, wobei der &quot;Index&quot;-Wert die Position in der Liste ist, die gesetzt oder hinzugefügt werden soll. Zum Beispiel erstellt die folgende <span class="notranslate">code</span> eine Liste und fügt dann 10 Einträge hinzu, wobei jeder Eintrag auf eine Zufallszahl von 0 bis 9 gesetzt wird:</p>
    <p class="code">ds = ds_list_create();<br />
      var _index = 0;<br />
      repeat(10)<br />
      {<br />
          ds[| _index++] = irandom(9);<br />
      }</p>
    <p class="dropspot">Beachten Sie, dass, wenn Sie einen Ausdruck verwenden, um einen Verweis auf einen Index hinzuzufügen, der bereits einen Wert hat, der vorherige Wert ersetzt wird und nicht ein weiterer Index zur Liste hinzugefügt wird. Um weitere Einträge hinzuzufügen, müssen Sie die Größe von ds_list kennen und sie an das Ende anhängen. Es ist auch erwähnenswert, dass Sie einen Listenindex setzen können, der <i>größer</i> ist als die Größe der Liste, auf die verwiesen wird, und dies wird diesen Wert setzen, wobei die Liste gleichzeitig erweitert wird und alle Positionen in der Liste bis zum angegebenen Index als 0 initialisiert werden.</p>
    <p class="dropspot">Wenn Sie Ihre Listenstruktur erstellt und mit Daten gefüllt haben, können Sie Werte aus der Liste abrufen, z. B. mit</p>
    <p class="code">value = ds[| 5];</p>
    <p class="dropspot">Die obige Funktion holt den Wert von Position 5 (dem sechsten Index, da Listen bei 0 beginnen) und speichert ihn in einer Variablen. Wenn Sie eine Position angeben, die außerhalb der Listengröße liegt, wird der Wert <span class="inline">undefined</span> zurückgegeben, was Sie mit der Funktion <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#">DS-Karten [? ]</a></p>
  <div class="droptext" data-targetname="drop-down13">
    <p class="dropspot">Die <span class="notranslate">syntax</span> für <a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">DS-Karten</a> lautet:</p>
    <p class="code">map_index[? key]</p>
    <p class="dropspot">Nachdem Sie Ihre Map mit <span class="inline">ds_map_create()</span> erstellt haben, verwenden Sie den Map-Index, den Sie in einer Variablen gespeichert haben, um darauf zu verweisen, wobei der Wert &quot;key&quot; der Map-Schlüssel ist, der gesetzt oder abgerufen werden soll. Das folgende Beispiel <span class="notranslate">code</span> erstellt eine Map und fügt ihr dann mit dieser Syntax ein paar Einträge hinzu:</p>
    <p class="code">ds = ds_map_create();<br />
      ds[? &quot;Name&quot;] = &quot;Hamish&quot;;<br />
      ds[? &quot;Company&quot;] = &quot;MacSeweeny Games&quot;;<br />
      ds[? &quot;Game&quot;] = &quot;Catch The Haggis&quot;;</p>
    <p class="dropspot">Wenn die Karte bereits denselben Schlüsselwert enthält, den Sie hinzufügen möchten, wird kein doppelter Schlüssel mit dem neuen Wert erstellt, sondern der vorherige Wert wird ersetzt.</p>
    <p class="dropspot">Wenn Sie Ihre Map-Struktur erstellt und mit Daten gefüllt haben, können Sie die Werte eines bestimmten Map-Schlüssels etwa so abrufen:</p>
    <p class="code">value = ds[? &quot;Name&quot;];</p>
    <p class="dropspot">Die obige Funktion holt sich den Wert des Schlüssels &quot;Name&quot; und speichert ihn in einer Variablen. Beachten Sie jedoch, dass der zurückgegebene Wert <span class="inline">undefined</span> lautet, wenn der angegebene Schlüssel nicht in der DS-Map vorhanden ist. Dies kann mit der Funktion überprüft werden <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#">DS-Gitter [# ]</a></p>
  <div class="droptext" data-targetname="drop-down14">
    <p class="dropspot">Die <span class="notranslate">syntax</span> für <a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm">DS grid</a> ist:</p>
    <p class="code">grid_index[# xpos, ypos]</p>
    <p class="dropspot">Nachdem Sie Ihr Gitter mit der Funktion <span class="inline">ds_grid_create()</span> erstellt haben, verwenden Sie den Gitterindex, den Sie in einer Variablen gespeichert haben, um darauf zu verweisen, wobei &quot;xpos&quot; und &quot;ypos&quot; die Position innerhalb des Gitters sind, um einen Wert zu erhalten oder zu setzen. Die folgende <span class="notranslate">code</span> beispielsweise erstellt ein Raster, setzt es auf 0 und fügt dann einige Einträge hinzu:</p>
    <p class="code">ds = ds_grid_create();<br />
      ds_grid_clear(ds, 0);<br />
      var _gw = ds_grid_width(ds) - 1;<br />
      var _gh = ds_grid_height(ds) - 1;<br />
      repeat(10)<br />
      {<br />
          var _xx = irandom(_gw);<br />
          var _yy = irandom(_gh);<br />
          if (ds[# _xx, _yy] == 0)<br />
          {<br />
              ds[# _xx, _yy] = 1;<br />
          }<br />
      }</p>
    <p class="dropspot">Wenn Sie Ihre Rasterstruktur erstellt und mit Daten gefüllt haben, können Sie Werte von einer bestimmten Rasterposition abrufen, indem Sie etwas wie folgt eingeben</p>
    <p class="code">value = ds[# mouse_x div 16, mouse_y div 16];</p>
    <p class="dropspot">Die obige Funktion ermittelt den Wert aus dem angegebenen ds_grid auf der Grundlage der Mausposition (geteilt durch die &quot;Zellen&quot;-Breite im Raum, um die richtige Position zu erhalten). Wenn Sie eine Position angeben, die außerhalb der Rastergrenzen liegt, wird der Wert <span class="inline">undefined</span> zurückgegeben, was Sie mit der Funktion <a href="../GML_Reference/Variable_Functions/is_undefined.htm"><span class="inline">is_undefined()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#">Arrays [@ ]</a></p>
  <div class="droptext" data-targetname="drop-down15">
    <p class="dropspot">Dieser Accessor wird nur verwendet, wenn die <a href="../../Settings/Game_Options.htm">Option Copy on Write</a> aktiviert ist.</p>
    <p class="dropspot">Arrays haben auch ihre eigenen Accessors, die ähnlich funktionieren wie die oben genannten für Datenstrukturen. Array-Accessors haben jedoch eine interessante Eigenschaft: Sie erlauben es, ein Array aus einer <a href="Script_Functions.htm">Skriptfunktion</a> heraus zu verändern oder <a href="Method_Variables.htm"><span class="notranslate">method</span></a> ohne es zu kopieren. Wenn Sie ein Array an eine Funktion übergeben, wird es <strong>per Referenz übergeben</strong>, d.h. das Array selbst wird nicht an <span class="notranslate">script</span> übergeben, sondern es wird einfach referenziert, um die Daten zu erhalten. Normalerweise würde das Array, wenn es geändert werden soll, auf <span class="notranslate">script</span> <em>kopiert </em>werden und dann müsste das kopierte Array zurückgegeben werden, damit das ursprüngliche Array aktualisiert werden kann. Dies kann einen kostspieligen Verarbeitungs-Overhead verursachen, weshalb Sie stattdessen den Accessor verwenden können, der das ursprüngliche Array <em>direkt </em>ändert, ohne dass es kopiert werden muss. In den folgenden Beispielen können Sie sehen, wie dies funktioniert.</p>
    <p class="dropspot">Die <span class="notranslate">syntax</span> für Arrays, die den <span class="inline">@</span> Accessor verwenden, ist:</p>
    <p class="code">array[@ i]</p>
    <p class="dropspot">Nachdem Sie Ihr Array in einer Instanz erstellt haben, können Sie es per Referenz an <span class="notranslate">script</span> übergeben und den Accessor <span class="inline">@</span> verwenden, um es direkt zu ändern. Zum Beispiel würden Sie das Array erstellen und die Funktion wie folgt aufrufen:</p>
    <p class="code">array[99] = 0;<br />
      array_populate(array);</p>
    <p class="dropspot">Die Funktion selbst würde etwa so aussehen:</p>
    <p class="code">function array_populate(_array)<br />
      {<br />
          var a = _array; var i = 0;<br />
          repeat(25)<br />
          {<br />
              i = irandom(99);<br />
              while (a[i] != 0)<br />
              {<br />
                  i = irandom(99);<br />
              }<br />
              a[@ i] = 100;<br />
          }<br />
      }</p>
    <p class="dropspot">Diese Funktion wählt lediglich 25 zufällige Positionen im Array aus und setzt den Wert der gewählten Array-Position auf 100.</p>
    <p class="dropspot">Natürlich ist der Accessor <span class="inline">@</span> nicht erforderlich, wenn <strong>Copy on Write</strong> deaktiviert ist.</p>
    <p class="note"><span class="note">HINWEIS</span> Sie können den Array-Accessor <span class="inline">@</span> nicht verwenden, wenn Sie mit dem Array <span class="inline">argument[n]</span> in Skriptfunktionen arbeiten.</p>
    <p class="dropspot"> </p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#">Strukturen [$ ]</a></p>
  <div class="droptext" data-targetname="drop-down16">
    <p class="dropspot"><span>Die <span class="notranslate">syntax</span> für <a href="Structs.htm">Structs</a> lautet</span></p>
    <p class="code">struct[$ &quot;name&quot;]</p>
    <p class="dropspot">Dieser Accessor ist im Wesentlichen ein Wrapper für die Funktionen <span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline">variable_struct_get()</span></a> und <a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline">variable_struct_set()</span></a>, und Sie würden ihn ähnlich wie den Accessor für eine DS-Map verwenden. Wenn Sie zum Beispiel eine Struktur erstellt haben und einen Wert aus einer Variablen namens &quot;my_health&quot; abrufen möchten, dann tun Sie das:</span></p>
    <p class="code">var _hp = struct[$ &quot;my_health&quot;];</p>
    <p class="dropspot">Wie Sie sehen können, geben Sie nicht die Variable selbst an, sondern eine <em>Zeichenkette</em> mit der Variable. Wenn die Struktur keine Variable mit dem angegebenen Namen hat, gibt der Accessor <span class="inline">undefined</span> als Wert zurück.</p>
    <p class="dropspot">Um eine Variable in einer Struktur zu setzen, gehen Sie wie folgt vor</p>
    <p class="code">struct[$ &quot;my_score&quot;] = 100;</p>
    <p class="dropspot">Wie beim Abrufen eines Wertes geben Sie den Namen der zu setzenden Variablen als String an, und sie wird auf den angegebenen Wert gesetzt. Wenn der verwendete Variablenname in der Struktur nicht vorhanden ist, wird er erstellt und auf den angegebenen Wert gesetzt.</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Ein wichtiges Merkmal von Accessors ist die Tatsache, dass sie miteinander <i>verkettet</i> werden können. Das bedeutet, dass Sie bei mehreren verschachtelten Datenstrukturen und/oder Arrays nicht mehr eine Vielzahl von Funktionen verwenden müssen, um auf einen Wert zuzugreifen, der tief in der verschachtelten Struktur liegt. Nehmen wir zum Beispiel an, Sie haben ein Array, und jedes Element im Array ist eine DS-Liste, etwa so:</p>
  <p class="code">array = array_create(3);<br />
    for (var i = 0; i &lt; 3; ++i;)<br />
    {<br />
        array[i] = ds_list_create();<br />
        switch(i)<br />
        {<br />
            case 0:<br />
                with (obj_Wall) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 1:<br />
                with (obj_Door) ds_list_add(array[i], id);<br />
            break;<br />
    <br />
            case 2:<br />
                with (obj_Chest) ds_list_add(array[i], id);<br />
            break;<br />
        }<br />
    }
  </p>
  <p>In der obigen <span class="notranslate">code</span> haben wir ein Array mit 3 Objekten erstellt und jedem von ihnen eine DS-Liste zugewiesen, und dann haben wir die verschiedenen Listen mit den Instanz-IDs der verschiedenen Objekte im Spiel gefüllt. Um nun auf eine ID in einer der Listen zuzugreifen, können wir folgendes tun:</p>
  <p class="code">var _list = array[0];<br />
    var _id = ds_list_find_value(_list, 0);</p>
  <p>Sie können jedoch dasselbe tun, indem Sie verkettete Accessors verwenden, und zwar auf eine viel sauberere Art und Weise, die weniger Code benötigt:</p>
  <p class="code">var _id = array[0][| 0];</p>
  <p>Sie können auf diese Weise mehrere Accessors miteinander verketten, und sie können von verschiedenen Typen sein, um Zugriff auf die in jedem Teil der verschachtelten Struktur gespeicherten Informationen zu erhalten. Hier sind einige weitere Beispiele:</p>
  <p class="code">// Access a grid that has been added to a list that is part of a map:<br />
    var _a = data[? &quot;lists&quot;][| 0][# 0, 0];<br />
    <br />
    // Access an array nested in a list from a script and modify it:<br />
    data[| 0][@ 10] = 100;<br />
    <br />
    // Access a map nested in a grid nested in a list nested in an array:<br />
    data[0][| 10][# 3, 4][? &quot;key&quot;] = &quot;hello world&quot;;
  </p>
  <p>Die Verwendung von verketteten Accessors bedeutet nicht nur, dass Sie kompaktere <span class="notranslate">code</span> schreiben können, sondern auch, dass Sie Iterationen (z. B. mit einer <a href="Language_Features/for.htm"><span class="inline">for</span></a> Schleife) und andere Techniken zu verwenden, um auf Ihre Daten sauberer und intuitiver zuzugreifen.</p>
  <p>Es ist erwähnenswert, dass Sie bei der Verwendung von Accessors auf diese Weise immer den <span class="inline">@</span> Accessor für Arrays verwenden sollten, da Sie andernfalls zusätzlichen Overhead zu den durchgeführten Aktionen hinzufügen. Wie bereits erwähnt, werden Arrays standardmäßig per Referenz an Funktionen übergeben und verwenden dann das Verhalten &quot;copy on write&quot;, wenn sie verändert werden. Wenn das Array jedoch Teil einer Kette ist, dann wird das vorherige Element in der Kette mit dem kopierten Array aktualisiert und das &quot;Original&quot; wird gelöscht. Zum Beispiel kann man so etwas tun:</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][0] = 200;
  </p>
  <p>führt zu den gleichen Ergebnissen wie diese Vorgehensweise:</p>
  <p class="code">// In an object event<br />
    data[| 0][0] = 100;<br />
    <br />
    // In a function<br />
    data[| 0][@ 0] = 200;
  </p>
  <p>Das zweite Beispiel ist jedoch besser, da es ohne den unnötigen Overhead des Kopierens des gesamten Arrays funktioniert.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Zurück: <a href="GML_Overview.htm">GML-Übersicht</a></div>
        <div style="float:right">Nächste: <a data-xref="{title}" href="Language_Features.htm">Sprachliche Merkmale</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Alle Rechte vorbehalten</span></h5>
  </div>
  <!-- KEYWORDS
div
mod
bitwise operators
bitshift
and
or
xor 
&amp;&amp;
||
^^
%
|
&amp;
^
&lt;&lt;
&gt;&gt;
bitwise or
bitwise and
bitwise xor
bitshift left
bitshift right
&lt;
&lt;=
==
!=
&gt;
&gt;=
++
$
hexadecimal
-->
  <!-- TAGS
expressions_operators
-->
</body>
</html>