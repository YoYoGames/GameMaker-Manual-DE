<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Variablen der Methode</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Gurpreet S. Matharoo" />
  <meta name="topic-comment" content="Page outlining the use of Method Variables" />
  <meta name="rh-index-keywords" content="Method Variables" />
  <meta name="search-keywords" content="Method Variables,methods,method" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Variablen der Methode</h1>
  <p>Eine Methodenvariable ist im Wesentlichen eine Variable, der eine Funktion zugewiesen wurde, die die Funktion an eine Instanz &quot;bindet&quot; und es Ihnen ermöglicht, die Variable zu verwenden, um auf die Funktion zu verweisen - ähnlich wie Sie einen <a href="Runtime_Functions.htm">Laufzeitfunktionsnamen</a> verwenden, um auf eine eingebaute <span class="notranslate">GML</span> Funktion zu verweisen. Die verwendete Variable kann einen <em>lokalen</em>, <em>instanziellen</em> oder <em>globalen</em> Geltungsbereich haben (weitere Informationen zum Geltungsbereich von Variablen finden Sie <a href="Variables_And_Variable_Scope.htm">hier</a> ).</p>
  <p>Siehe auch: <a data-xref="{title}" href="Script_Functions_vs_Methods.htm">Skriptfunktionen vs. Methoden</a></p>
  <h2>Methoden erstellen</h2>
  <p>Die <span class="notranslate">syntax</span> für die Erstellung einer Methodenvariable lautet wie folgt:</p>
  <p class="code"><span><span>name = </span>function( parameter1, parameter2, ... )</span><br />
    <span>{</span><br />
    <span>    statement1;</span><br />
    <span>    statement2;</span><br />
    <span>    ...</span><br />
    <span>}</span>
  </p>
  <p>oder</p>
  <p class="code"><span>function name( parameter1, parameter2, ... )<br />
      {</span><br />
    <span>    statement1;</span><br />
    <span>    statement2;</span><br />
    <span>    ...</span><br />
    <span>}</span>
  </p>
  <p class="note">Um eine Funktion in <span class="notranslate">GML</span> Visual zu erstellen, verwenden Sie <a data-xref="{title}" href="../../Drag_And_Drop/Drag_And_Drop_Reference/Common/Declare_A_New_Function.htm">Declare A New Function</a>. Aktivieren Sie die Option &quot;Temp&quot;, um eine Methodenvariable zu erstellen (siehe <span class="notranslate">syntax</span> oben).</p>
  <p>Im Allgemeinen sollten Sie jedoch die <em>erste </em>Form für Methoden und die zweite Form für die Definition von <a href="Script_Functions.htm">Skriptfunktionen</a> verwenden, da die zweite Form dem Funktionsnamen auch einen <span class="notranslate">script</span> Index zuweist, während die erste Form eine &quot;echte&quot; Methode ist (und die Verwendung des <a href="Variables/Global_Variables.htm"><span class="notranslate">global</span></a> Präfixes erfordert, wenn man eine Skriptfunktion definiert).</p>
  <p class="note"><span class="note">HINWEIS</span> Sie können dies überprüfen, indem Sie beide Formulare im Projekt verwenden und dann die Funktion <span class="notranslate">runtime</span> <a href="../GML_Reference/Variable_Functions/typeof.htm">typeof()</a> für jedes von ihnen aufrufen. Das eine wird als &quot;Zahl&quot; eingestuft - da es eine <span class="notranslate">script</span> Index-ID zurückgibt - und das andere als &quot;Methode&quot;.</p>
  <p>Denken Sie also daran, dass wir uns im Allgemeinen immer auf Funktionen beziehen, die <em>nicht </em>mit einem Index <span class="notranslate">script</span> definiert wurden, wenn wir über Methoden und Methodenvariablen sprechen. </p>
  <p>Nachfolgend sehen Sie drei einfache Beispiele für die Erstellung einer Methodenvariable unter Verwendung verschiedener Geltungsbereiche:</p>
  <p class="code">// Local<br />
    var _debug = function(message)<br />
    {<br />
        show_debug_message(message);<br />
    }<br />
    <br />
    // Instance<br />
    do_maths = function(val1, val2, val3)<br />
    {<br />
        return (val1 * val2) - val3;<br />
    }<br />
    <br />
    // Global<br />
    global.pd = function(_x1, _y1, _x2, _y2);<br />
    {<br />
        return point_distance(_x1, _y1, _x2, _y2);<br />
    }
  </p>
  <p>Beachten Sie, dass in der obigen <span class="notranslate">code</span> die verschiedenen Parameter, die als Eingaben für die Funktion angegeben werden, alle benannt sind und diese Namen innerhalb der Funktion verwendet werden sollten, um auf die verschiedenen Eingaben zu verweisen. Beachten Sie auch, dass Sie die Anweisung <span class="inline"><a href="Language_Features/return.htm">return</a></span> verwenden können, um einen Wert aus einer Funktion für die Verwendung an anderer Stelle in Ihrem <span class="notranslate">code</span> zurückzugeben, und dass eine Funktion, für die <em>kein</em> Rückgabewert definiert ist, standardmäßig <span class="inline">undefined</span> zurückgibt.</p>
  <p class="note"><span class="note">HINWEIS</span> Während die Variable im gewählten Bereich liegt, ist die eigentliche Funktion an den Bereich gebunden, in dem sie ursprünglich definiert wurde. <a href="Script_Functions.htm">Wenn</a> Sie jedoch eine Funktion <span class="notranslate">script</span> haben, die eine andere Funktion als Methodenvariable erstellt, und dann diese Funktion <span class="notranslate">script</span> von einer Instanz aus aufrufen, wird die in <span class="notranslate">script</span> verwendete Funktion <strong>als Methode an die Instanzvariable gebunden</strong>. Im Allgemeinen müssen Sie sich darüber keine Gedanken machen, aber bei komplexeren Operationen mit Methodenvariablen lohnt es sich, dies in Betracht zu ziehen. Dies gilt auch bei der Verwendung anderer Konstrukte wie <a href="Language_Features/with.htm"><span class="inline">with</span></a> - wenn Sie eine Methodenvariable innerhalb eines With erstellen, wird die Funktion an die Instanz gebunden, die sich gerade im Gültigkeitsbereich befindet.</p>
  <p>Sobald die Methodenvariable erstellt ist, kann sie genauso verwendet werden wie eine <span class="notranslate">runtime</span> Funktion oder eine <span class="notranslate">script</span> Funktion, zum Beispiel:</p>
  <p class="code">create_vec = function(_x1, _y1, _x2, _y2);<br />
    {<br />
        var _array;<br />
        _array[0] = point_distance(_x1, _y1, _x2, _y2);<br />
        _array[1] = point_direction(_x1, _y1, _x2, _y2);<br />
        return _array;<br />
    }<br />
    <br />
    vec = create_vec(x, y, mouse_x, mouse_y);
  </p>
  <p>Für Variablen, die innerhalb einer Funktion erstellt werden, gelten dieselben Regeln wie für normale Variablen, und sie werden entsprechend dem verwendeten Schlüsselwort oder dem Bereich des Funktionsaufrufs zugewiesen. Im obigen Beispiel verwenden wir <span class="inline">var</span>, so dass die Array-Variable in den <em>lokalen </em>Bereich der Funktion fällt. Hätten wir das Schlüsselwort nicht verwendet, dann wäre die Variable im Bereich der Instanz erstellt worden, die die Funktion aufgerufen hat.</p>
  <p>Methoden, genau wie <span class="notranslate">script</span> Funktionen, können auch optionale <span class="notranslate">arguments</span> nehmen, die Standardwerte haben, wenn sie nicht übergeben werden:</p>
  <p class="code">create_attachment = function(_attachment, <strong>_x = x</strong>, <strong>_y = y</strong>)<br />
    {<br />
        return instance_create_layer(_x, _y, layer, _attachment);<br />
    }</p>
  <p>Die obige Funktion benötigt drei <span class="notranslate">arguments</span>, wobei die letzten beiden optional sind. Wenn sie beim Aufruf der Funktion nicht mitgegeben werden, werden standardmäßig die Koordinaten der Instanz <span class="inline">x</span> und <span class="inline">y</span> verwendet.</p>
  <p>Wird <span class="notranslate">argument</span> nicht übergeben und hat es keinen Standardwert, so ist es gleich <span class="inline">undefined</span>.</p>
  <p>Methoden können auch statische Variablen verwenden, die ihre Werte bei jedem Funktionsaufruf beibehalten. Bitte <a href="Functions/Static_Variables.htm">lesen Sie diese Seite</a> für weitere Informationen.</p>
  <p>Im Folgenden werden einige Hilfsfunktionen aufgeführt, die mit Methodenvariablen verbunden sind:</p>
  <ul class="colour">
    <li><a href="../GML_Reference/Variable_Functions/is_method.htm"><span class="notranslate">is_method</span></a></li>
    <li><a href="../GML_Reference/Variable_Functions/method.htm"><span class="notranslate">method</span></a></li>
    <li><a href="../GML_Reference/Variable_Functions/method_get_self.htm"><span class="notranslate">method_get_self</span></a></li>
    <li><a href="../GML_Reference/Variable_Functions/method_get_index.htm"><span class="notranslate">method_get_index</span></a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Zurück: <a href="GML_Overview.htm">GML-Übersicht</a></div>
        <div style="float:right">Nächste: <a data-xref="{title}" href="Script_Functions_vs_Methods.htm">Skriptfunktionen vs. Methoden</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Alle Rechte vorbehalten</span></h5>
  </div>
  <!-- KEYWORDS
Script Functions
User Defined Functions
-->
  <!-- TAGS
method_variables
-->
</body>
</html>