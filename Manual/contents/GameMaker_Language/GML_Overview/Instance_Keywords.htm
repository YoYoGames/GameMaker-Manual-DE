<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Instanz-Schlüsselwörter</title>
    <meta name="generator" content="Adobe RoboHelp 2020" />
    <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
    <script src="../../assets/scripts/main_script.js"></script>
    <meta name="rh-authors" content="Mark Alexander" />
    <meta name="topic-comment" content="Page outlining the different instance &quot;keywords&quot;" />
    <meta name="rh-index-keywords" content="Instance Keywords,noone,self,other,all" />
    <meta name="search-keywords" content="self,all,noone,other,instance keywords" />
  </head>
  <body><!--<div class="body-scroll" style="top: 150px;">-->
    <h1>Instanz-Schlüsselwörter</h1>
    <p>Um bestimmte Dinge in <span data-keyref="GameMaker Name">GameMaker</span> zu vereinfachen, können Sie eines von mehreren <b>Instanz-Schlüsselwörtern</b> in Ihrem <span class="notranslate">code</span> (ob <span class="notranslate">GML</span> oder <span class="notranslate">GML</span> Visual) verwenden. Diese Schlüsselwörter werden in erster Linie verwendet, um Instanzen - und in einigen Fällen auch Strukturen - in verschiedenen Situationen zu identifizieren, und jedes wird im folgenden Text erklärt.</p>
    <p>Beachten Sie, dass alle angegebenen Schlüsselwörter intern durch <strong>negative Integer-Werte</strong> repräsentiert werden, so dass bei der Zuweisung oder Überprüfung von Variablenwerten gegen oder mit diesen Schlüsselwörtern Vorsicht geboten ist, da es später zu unerwarteten Ergebnissen kommen kann, da <span data-keyref="GameMaker Name">GameMaker</span> den von Ihnen verwendeten Wert als etwas anderes interpretiert. Beachten Sie auch, dass die direkte Verwendung von Integer-Werten anstelle der Schlüsselwörter in <span class="notranslate">code</span> <b>nicht empfehlenswert</b> ist und später zu Problemen führen kann.</p>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span class="inline">self</span></a></p>
    <div class="droptext" data-targetname="drop-down">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Schlüsselwort</th>
            <th>Beschreibung</th>
            <th>Wert</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">self</span></td>
            <td>Die Instanz/Konstruktion, die den aktuellen Block von <span class="notranslate">code</span> ausführt.</td>
            <td><span class="notranslate">   -1</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot"><span class="inline">self</span> kann verwendet werden, um die aktuelle Struktur oder Instanz zu identifizieren, die sich im aktuellen Block von <span class="notranslate">code</span> im Geltungsbereich befindet:</p>
      <p class="code">var val = 100;
        <br/>
        with (instance_create_layer(x, y, &quot;Instances&quot;, obj_Fire))
        <br/>
        {
        <br/>
        self.val = val;
        <br/>
        }</p>
      <p class="dropspot">In diesem Beispiel sehen Sie, dass wir eine <i>lokale</i> Variable mit dem Namen <span class="inline">val</span> haben und die <i>Instanzvariable</i> mit demselben Namen in der neu erstellten Objektinstanz setzen wollen. Um die Instanzvariable korrekt zu identifizieren und <span data-keyref="GameMaker Name">GameMaker</span> anzuweisen, sie in der Instanz zu setzen, die den Block <span class="notranslate">code</span> aufruft, verwenden wir das Schlüsselwort <span class="inline">self</span>. In den meisten Fällen kannst du auch die eingebaute Instanzvariable <span class="inline">id</span> anstelle von <span class="inline">self</span> verwenden, aber <span class="inline">self</span> bietet gewisse Vorteile. Zunächst einmal ist es für <span class="notranslate">compiler</span> schneller, die Instanz (oder Struktur) mit <span class="inline">self</span> statt mit <span class="inline">id</span> zu identifizieren, da der Wert <span class="inline">id</span> die Instanz-Lookup-Tabelle durchläuft, während <span class="inline">self</span> dies nicht tut. Zweitens ist es für diejenigen, die Erweiterungen erstellen, sehr nützlich, das korrekte Scoping von Variablen sicherzustellen, da es möglich ist, dass ein Projekt, das eine Erweiterung verwendet, eine Variable mit globalem Geltungsbereich oder etwas mit demselben Namen wie eine Variable in der Erweiterung hat.</p>
      <p class="note"><strong>HINWEIS</strong>: Das Schlüsselwort <span class="inline">self</span> ist <strong>keine </strong>Abkürzung für den tatsächlichen ID-Wert einer Instanz oder Struktur und sollte nur in dem oben erläuterten Zusammenhang verwendet werden. Wenn Sie den <strong>ID-Wert </strong>für eine Instanz benötigen, müssen Sie <span class="inline">self.id</span> verwenden, z. B:</p>
      <p class="code">var myID = id;
        <br/>
        with (all)
        <br/>
        {
        <br/>
        if self.id == myID
        <br/>
        {
        <br/>
        // do something
        <br/>
        }
        <br/>
        }</p>
      <p class="dropspot">Es ist auch erwähnenswert, dass <span class="inline">self</span> auch innerhalb von <a href="Structs.htm">Structs</a> verwendet werden kann - unter sehr spezifischen Umständen - um Mitgliedsvariablen für die Struktur zu referenzieren.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span class="inline">other</span></a></p>
    <div class="droptext" data-targetname="drop-down1">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Schlüsselwort</th>
            <th>Beschreibung</th>
            <th>Wert</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">other</span></td>
            <td>Die andere Instanz, die an einem Kollisionsereignis, an einer Funktion <span class="inline">with</span> oder an einer Funktion beteiligt ist.</td>
            <td><span class="notranslate">   -2</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">Das spezielle Schlüsselwort <span class="inline">other</span> kann auf mehrere Arten verwendet werden, um auf eine bestimmte Instanz (und in einigen Fällen auf eine Struktur) zu verweisen: Es kann in einer <span class="inline">with</span> -Anweisung ( <a href="Language_Features/with.htm">hier</a> erklärt), in einem <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">Kollisionsereignis</a> oder in einer Funktion verwendet werden. In diesem Abschnitt werden die letzten beiden Anwendungsfälle erläutert.</p>
      <p class="dropspot">Beachten Sie, dass <span class="inline">other</span> bei anderen Ereignissen als dem Kollisionsereignis außerhalb von Funktionsaufrufen und <span class="inline">with()</span> -Blöcken einfach die Struktur für die aktuelle Instanz zurückgibt.</p>
      <h2 class="dropspot">Kollisionsereignis</h2>
      <p class="dropspot">Ein Kollisionsereignis kann nur zwischen <strong>zwei </strong>Instanzen auftreten. Du <i>kannst</i> mehrere Kollisionen zwischen mehreren Instanzen haben, aber sie werden alle von <span data-keyref="GameMaker Name">GameMaker</span> auf einer 1:1-Basis aufgelöst, mit der &quot;eigenen&quot; Instanz, die das Kollisionsereignis hat, und der &quot;anderen&quot; Instanz, die mit ihr kollidiert.</p>
      <p class="dropspot">Stell dir vor, du hast eine Spielerinstanz, mehrere Feindinstanzen und mehrere Geschossinstanzen, die der Feind auf dich abfeuern kann. Sie können jedem Feind eine einzelne Geschossinstanz zuweisen, aber mit einer anderen Schadensvariablen, die ihm zum Beispiel bei der Erstellung zufällig zugewiesen wird:</p>
      <p class="code">var bullet;
        <br/>
        bullet = instance_create_layer(x, y, &quot;Bullets&quot;, obj_Bullet);
        <br/>
        bullet.damage = 5 + irandom(5);
        <br/>
        bullet.speed = 8;
        <br/>
        bullet.direction = point_direction(x, y, obj_Player.x, obj_Player.y);</p>
      <p class="dropspot">Sie können sehen, wie wir seine Variablen mit der Punktnotation setzen, wie im Abschnitt über die <a href="Addressing_Variables_In_Other_Instances.htm">Adressierung von Variablen in anderen Instanzen</a> beschrieben. Dadurch erhält jede Geschossinstanz einen anderen Schadenswert, aber wie erkennt der Spieler den Schaden, den er erleiden muss, wenn er von einem Geschoss getroffen wird?</p>
      <p class="dropspot">Dazu muss der Spieler ein Kollisionsereignis mit <span class="inline">obj_Bullet</span> haben und innerhalb dieses Ereignisses <span class="inline">other</span> verwenden, um Variablen aus der kollidierenden Geschossinstanz zu lesen:</p>
      <p class="code">hp -= other.damage;
        <br/>
        if hp &lt;= 0 instance_destroy();</p>
      <p class="dropspot">Die obige <span class="notranslate">code</span> zieht den Betrag, der in der &quot;damage&quot;-Variablen der <i>anderen</i> Instanz gespeichert ist, von der &quot;hp&quot;-Variablen des Spielers ab und prüft dann, ob die &quot;hp&quot; kleiner oder gleich 0 ist. Wenn ja, wird die Spielerinstanz zerstört. Bitte beachte, dass die andere Instanz die zu prüfende Variable haben muss, sonst wird ein Fehler ausgelöst.</p>
      <p class="note"><strong>HINWEIS</strong>: Das Ereignis "Kollision" ist das einzige Ereignis, das eine besondere Bedeutung für das Schlüsselwort <span class="inline">other</span> hat. Bei allen anderen Ereignissen und <span class="notranslate">scripts</span> wird das Verhalten von <span class="inline">other</span> durch den Kontext definiert, in dem es verwendet wird (z. B. ein <span class="inline">with() </span>Block, eine Funktion, eine Strukturdeklaration usw.).</p>
      <p class="dropspot">Sie können den Variablen Werte zuweisen oder sogar neue Variablen erstellen, indem Sie <span class="inline">other</span> im Kollisionsereignis verwenden, etwa so:</p>
      <p class="code">// add ten to the other instance &quot;mana&quot; variable
        <br/>
        other.mana += 10;
        <br/>
        // set the other instance variable &quot;hit&quot; to true, creating the variable if it doesn&#39;t already exist
        <br/>
        other.hit = true;</p>
      <h2 class="dropspot">Struktur-Erklärung</h2>
      <p class="dropspot">Wenn es innerhalb einer struct-Deklaration verwendet wird, bezieht sich <span class="inline">other</span> auf die Instanz, die die struct initialisiert:</p>
      <p class="code">var _struct =
        <br/>
        {
        <br/>
        parent_instance : other
        <br/>
        }
        <br/>
        <br/>
        show_debug_message(_struct.parent_instance == self);
        <br/>
        // This prints &#39;1&#39; (true) meaning that both sides refer to the same instance </p>
      <p class="dropspot">Sie müssen jedoch nicht <span class="inline">other</span> verwenden, um Variablen aus der Instanz zu lesen, da alle Variablen, auf die Sie direkt verweisen, aus dem Bereich der Instanz gelesen werden, wie <a href="Structs.htm#inst_in_struct">in diesem Abschnitt</a> des Handbuchs beschrieben. Sie müssen dies nur verwenden, wenn Sie einen Verweis auf die Struktur der Instanz speichern wollen.</p>
      <h2 class="dropspot">Instanz-Methode</h2>
      <p class="dropspot">Die Verwendung von <span class="inline">other</span> innerhalb der Methode einer anderen Instanz <a href="Method_Variables.htm"><span class="notranslate">method</span></a> bezieht sich auf die Instanz, die diese Methode aufgerufen hat.</p>
      <p class="dropspot">Ein Beispiel: <span class="inline">Object2</span> hat eine Methode, die auf <span class="inline">self</span> und <span class="inline">other</span> verweist. Diese Methode wird dann in <span class="inline">Object1</span> aufgerufen. Da die Methode in <span class="inline">Object2</span> erstellt wurde, ist sie an diese <strong>gebunden</strong> und wird immer die Instanz <span class="inline">Object2</span> als &quot;Selbst&quot; verwenden, egal welche Instanz sie aufruft. In einem solchen Fall wird die aufrufende Instanz <span class="inline">other</span>.</p>
      <p class="code">// In Object2
        <br/>
        my_method = function()
        <br/>
        {
        <br/>
        show_debug_message(object_get_name(self.object_index));
        <br/>
        show_debug_message(object_get_name(other.object_index));
        <br/>
        }
        <br/>
        <br/>
        // In Object1
        <br/>
        Object2.my_method(); </p>
      <p class="dropspot">Dies würde dazu führen, dass die Instanz zuerst ihren eigenen Objektnamen (&quot;Object2&quot;) und dann den Objektnamen der aufrufenden Instanz (&quot;Object1&quot;) ausgibt.</p>
      <p class="dropspot">Dasselbe gilt für eine Methode, die an eine Struktur gebunden ist.</p>
      <h2 class="dropspot">Konstrukteur Funktion</h2>
      <p class="dropspot">Wenn es innerhalb einer Konstruktorfunktion verwendet wird, verweist <span class="inline">other</span> auf die Instanz, die diese Funktion aufruft. Dies wird jedoch nicht für den allgemeinen Gebrauch empfohlen, da alle externen Daten, die ein Konstruktor verwenden muss, als <span class="notranslate">arguments</span> übergeben werden sollten.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span class="inline">all</span></a></p>
    <div class="droptext" data-targetname="drop-down2">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Schlüsselwort</th>
            <th>Beschreibung</th>
            <th>Wert</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">all</span></td>
            <td>Alle Instanzen, die derzeit in dem Raum aktiv sind.</td>
            <td><span class="notranslate">   -3</span></td>
          </tr>
        </tbody>
      </table>
      <p> </p>
      <p class="dropspot">Dieses Schlüsselwort wird verwendet, um dem <span data-keyref="GameMaker Name">GameMaker</span> mitzuteilen, dass eine Funktion auf alle aktiven Instanzen innerhalb eines Raumes angewendet oder geprüft werden soll (deaktivierte Instanzen werden nicht geprüft oder angesprochen). Du <b>kannst</b> <span class="inline">all</span> <b>nicht</b> verwenden, um mit der Point-Methode (siehe <a href="Addressing_Variables_In_Other_Instances.htm">hier</a>) auf Variablen in anderen Instanzen zuzugreifen oder diese zu setzen, aber du <strong>kannst </strong>es verwenden, wenn du <a href="Language_Features/with.htm"><span class="inline">with()</span></a>verwenden, zum Beispiel:</p>
      <p class="code">with (all)
        <br/>
        {
        <br/>
        speed = 0;
        <br/>
        }</p>
      <p class="dropspot">Die obige <span class="notranslate">code</span> setzt die Geschwindigkeit aller Instanzen im Raum auf 0. Du kannst auch <span class="inline">all</span> innerhalb von Funktionen verwenden, um z.B. alle Instanzen im Raum anzuvisieren oder zu überprüfen:</p>
      <p class="code">// Check a point for any active instance in the room
        <br/>
        inst = instance_position(mouse_x, mouse_y, all);
        <br/>
        <br/>
        // Check all instances for a collision along a line
        <br/>
        if collision_line(x, y, mouse_x, mouse_y, all, false, true) {}
        <br/>
        <br/>
        // Add all instances in the room into a motion planning grid
        <br/>
        mp_grid_add_instances(grid, all, false); </p>
      <p class="dropspot"><span class="inline">all</span> ist ein sehr nützliches Schlüsselwort und kann in zahlreichen Situationen innerhalb Ihrer <span class="notranslate">code</span> und Aktionen verwendet werden, wodurch sich die Anzahl der <span class="notranslate">code</span>, die Sie schreiben müssen, um einen gewünschten Effekt zu erzielen, oft verringert.</p>
      <p class="dropspot"> </p>
    </div>
    <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#"><span class="inline">noone</span></a></p>
    <div class="droptext" data-targetname="drop-down3">
      <table class=" cke_show_border">
        <tbody>
          <tr>
            <th>Schlüsselwort</th>
            <th>Beschreibung</th>
            <th>Wert</th>
          </tr>
          <tr>
            <td><span class="notranslate"><span class="inline">noone</span></td>
            <td>Kein einziger Fall.</td>
            <td><span class="notranslate">   -4</span></td>
          </tr>
        </tbody>
      </table>
      <p class="dropspot">Es mag seltsam erscheinen, aber beim Programmieren eurer Spiele werdet ihr oft die Notwendigkeit haben, zu prüfen, ob an einem Ort oder in einer Kollision usw. keine Instanzen gefunden werden. In diesen Fällen würden Sie dieses Schlüsselwort verwenden, um zu prüfen, ob nichts gefunden wurde, etwa so:</p>
      <p class="code">if instance_nearest(x, y, obj_enemy) != noone
        <br/>
        {
        <br/>
        //do something as there is an enemy instance near
        <br/>
        }</p>
      <p class="dropspot">In diesem Beispiel gibt die Funktion <span class="inline">instance_nearest()</span> entweder <span class="inline">noone</span> oder die eindeutige ID der nächstgelegenen gefundenen Instanz zurück. Grundsätzlich können Sie jedes Mal, wenn Sie nach einer Instanz suchen müssen, erwarten, dass Sie entweder <span class="inline">noone</span> oder eine eindeutige Instanz-ID zurückerhalten.</p>
      <p class="dropspot"> </p>
    </div>
    <p> </p>
    <p> </p>
    <p> </p>
    <div class="footer">
      <div class="buttons">
        <div class="clear">
          <div style="float:left">Zurück: <a href="GML_Overview.htm">GML-Übersicht</a></div>
          <div style="float:right">Nächste: <a data-xref="{title}" href="Evaluation_Order.htm">Bewertungsauftrag</a></div>
        </div>
      </div>
      <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Alle Rechte vorbehalten</span></h5>
    </div>
    <!-- KEYWORDS
Instance Keywords
self
all
noone
other
--><!-- TAGS
instance_keywords
--></body>
</html>