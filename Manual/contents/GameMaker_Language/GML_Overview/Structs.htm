<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Strukturen &amp; Konstrukteure</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Gurpreet S. Matharoo" />
  <meta name="topic-comment" content="Page outlining the use of Structs" />
  <meta name="rh-index-keywords" content="Structs" />
  <meta name="search-keywords" content="structs,new,delete,struct" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Strukturen &amp; Konstrukteure</h1>
  <p>Ein <strong>struct </strong>ist eine Variable, die eine Sammlung von anderen Variablen enthält. Die Variablen, die ein struct enthält, können jeden der zuvor genannten <a href="Data_Types.htm">Datentypen</a> haben, und diese Variablen können nach der anfänglichen struct-Deklaration gelesen und beschrieben werden; außerdem können Sie einem struct weitere Variablen hinzufügen, nachdem es deklariert wurde.</p>
  <p>Die in einer struct verwendeten Variablen sollten dem üblichen Schema für die Benennung von Variablen folgen, d.h.: sie dürfen nicht mit einer Zahl beginnen und sollten nur aus alphanumerischen Zeichen und dem Unterstrich &quot;_&quot; bestehen. Beachten Sie auch, dass der Inhalt einer struct <em>unabhängig von der Instanz oder Funktion</em> ist <em>, die sie erstellt hat</em>, und dass Sie daher - wenn Sie möchten - eingebaute Variablennamen wie <span class="inline">image_index</span> oder <span class="inline">x</span> und <span class="inline">y</span> verwenden können.</p>
  <p>Nach der anfänglichen Erstellung haben structs keinen Verarbeitungsaufwand, solange sie existieren, obwohl <i>sie</i> Speicherplatz benötigen. Die Struktur <span class="notranslate">syntax</span> ist wie folgt aufgebaut:</p>
  <p class="code"><i>&lt;variable&gt;</i> =<br />
    {<br />
    <i>    &lt;variable&gt;</i> : <i>&lt;value&gt;</i>,<br />
    <i>    &lt;variable&gt;</i> : <i>&lt;value&gt;</i>,<br />
        etc...<br />
    };
  </p>
  <p>Ein Beispiel aus der Praxis wäre also Folgendes:</p>
  <p class="code">mystruct =<br />
    {<br />
        a : 20,<br />
        b : &quot;Hello World&quot;<br />
    };</p>
  <p>Die obige <span class="notranslate">code</span> erstellt eine Instanzbereich-Struktur in der Variablen <span class="inline">mystruct</span> und füllt sie mit einigen Werten (Strukturen können im lokalen, Instanz- und globalen Bereich erstellt werden, genau wie jede andere Variable - siehe den Abschnitt über <a href="Variables_And_Variable_Scope.htm">Variablen und Variablenbereich</a> für weitere Informationen). Beachten Sie, dass Sie den Inhalt einer Struktur nicht auffüllen müssen, wenn sie anfänglich erstellt wird, und Sie können eine leere Struktur erstellen, indem Sie dies einfach tun:</p>
  <p class="code">mystruct = {};</p>
  <p>Variablen können dann zu einem späteren Zeitpunkt im Spiel zu dieser Struktur hinzugefügt werden <span class="notranslate">code</span>. Um sie nachträglich hinzuzufügen, verwenden Sie den Punkt-Operator (wie bei der <a href="Addressing_Variables_In_Other_Instances.htm">Adressierung von Variablen in anderen Instanzen</a>): </p>
  <p class="code">mystruct.newItem = &quot;Some Text&quot;;</p>
  <p>Dies hat das gleiche Ergebnis wie die Initialisierung der Struktur auf diese Weise: </p>
  <p class="code">mystruct =<br />
    {<br />
        newItem : &quot;Some Text&quot;<br />
    };</p>
  <p>Hier ist ein Beispiel für eine Struktur mit verschiedenen Variablen und Datentypen:</p>
  <p class="code">var _xx = 100;<br />
    mystruct =<br />
    {<br />
        a : 10,<br />
        b : &quot;Hello World&quot;,<br />
        c : int64(5),<br />
        d : _xx + 50,<br />
        e : function(a, b)<br />
            {<br />
                return a + b;<br />
            },<br />
        f : [ 10, 20, 30, 40, 50 ],<br />
        g : image_index<br />
    };</p>
  <p>Sie werden in der obigen <span class="notranslate">code</span> feststellen, dass Sie auch Methoden definieren und <span class="notranslate">runtime</span> Funktionen in structs verwenden können, und Sie können auch lokale und Instanzvariablen innerhalb der struct-Deklaration verwenden.</p>
  <h3 id="inst_in_struct">Instanzvariablen in der Strukturdeklaration?</h3>
  <p>Im obigen Beispiel werden Sie feststellen, dass die Strukturvariable &quot;g&quot; auf <span class="inline">image_index</span> gesetzt wird, die eine Instanzvariable ist. Man könnte meinen, dass man in diesem Fall das <a href="Instance_Keywords.htm">Schlüsselwort</a> <span class="inline">other</span> verwenden muss, um die Instanzvariable zu erhalten, aber das ist nicht notwendig. Wenn Sie eine Struktur definieren<strong>, sind alle Mitgliedsvariablen auf der linken Seite des Doppelpunkts &quot;:&quot; die <em>Strukturvariablen</em></strong>, und die Werte und Variablen auf der rechten Seite verwenden den Geltungsbereich dessen, was die Struktur definiert (in diesem Fall eine Instanz). </p>
  <p>Schauen wir uns ein einfaches Beispiel an, um dies zu veranschaulichen. Nehmen wir an, Sie möchten eine Struktur mit den Variablen &quot;x&quot; und &quot;y&quot; definieren und diese auf die &quot;x&quot; und &quot;y&quot; der Instanz setzen, die die Struktur definiert. In der Praxis würde die <span class="notranslate">code</span> wie folgt aussehen:</p>
  <p class="code">mystruct =<br />
    {<br />
        x : x,<br />
        y : y<br />
    };</p>
  <p>In der obigen <span class="notranslate">code</span> werden die struct-Mitgliedsvariablen <span class="inline">x</span> und <span class="inline">y</span> auf die Werte gesetzt, die in den Instanzvariablen <span class="inline">x</span> und <span class="inline">y</span> enthalten sind, da sich die rechte Seite des Doppelpunkts &quot;:&quot; auf die Instanz bezieht, die die struct definiert. Es ist zu beachten, dass dies bedeutet, dass Sie <em>keine</em> struct-Mitgliedsvariablen für die Definition nachfolgender Variablen innerhalb der struct-Deklaration verwenden können. Das folgende Beispiel würde zu einem Fehler führen:</p>
  <p class="code">mystruct =<br />
    {<br />
        a : 10,<br />
        b : 10,<br />
        c : a + b<br />
    }</p>
  <p>Der Fehler tritt auf, weil die Variablen <span class="inline">a</span> und <span class="inline">b</span> tatsächlich im Geltungsbereich dessen ausgewertet werden, der die Struktur definiert (sie befinden sich auf der rechten Seite des Doppelpunkts &quot;:&quot;), und <em>nicht</em> in der Struktur selbst definiert werden.<strong></strong></p>
  <h3 style="padding-left: 20px"><em><strong style="margin-left: 0px">WICHTIG!</strong></em>  Sie <strong>können </strong>keine eingebauten <em><strong>global </strong></em>Bereichsvariablen als Namen von Strukturmitgliedern verwenden, z.B.: <span class="inline">game_id</span> oder <span class="inline">fps</span>. Eine vollständige Liste dieser globalen Variablen finden Sie auf der folgenden Seite:</h3>
  <ul class="colour">
    <li><a href="Struct_Forbidden_Variables.htm">Struktur Verbotene Variablen</a></li>
  </ul>
  <p>Sobald eine Struktur definiert ist, können Sie auf die darin enthaltenen Daten zugreifen, indem Sie die &quot;Punkt&quot;-Notation wie folgt verwenden:</p>
  <p class="code">mystruct =<br />
    {<br />
        a : 20,<br />
        b : &quot;Hello World&quot;<br />
    }<br />
    <br />
    mystring = mystruct.b + string(mystruct.a);
  </p>
  <p>Sie können auch Operationen mit den Variablen innerhalb einer Struktur durchführen oder sie in Funktionen verwenden, so wie Sie es mit jeder anderen Variablen tun würden. Zum Beispiel:</p>
  <p class="code">mystruct.a += 1;<br />
    mystruct.b = mystruct.a + 20;<br />
    mydir = point_direction(mouse_x, mouse_y, mystruct.xx, mystruct.yy);</p>
  <p>Schließlich können Structs andere Structs in sich verschachtelt haben, wie hier:</p>
  <p class="code">mystruct =<br />
    {<br />
        a :<br />
        {<br />
            aa : &quot;This is an example&quot;<br />
        },<br />
        b :<br />
        {<br />
            bb : &quot;And another one&quot;<br />
        },<br />
    };</p>
  <p>Um auf solche verschachtelten Strukturen zuzugreifen, würden Sie weiterhin die Punktnotation verwenden, etwa so:</p>
  <p class="code">var _str = mystuct.a.aa + &quot; &quot; + mystruct.b.bb;<br />
    show_debug_message(_str);</p>
  <p>Eine weitere Möglichkeit, auf Daten in einer Struktur zuzugreifen, besteht in der Verwendung der <a href="Language_Features/with.htm"><span class="inline">with()</span></a> Funktion. So könnten Sie zum Beispiel Folgendes tun:</p>
  <p class="code">with(mystruct)<br />
    {<br />
        a += other.x;<br />
    }</p>
  <p>Die Verwendung von <span class="inline">with()</span> ändert den Geltungsbereich von <span class="notranslate">code</span> auf die angegebene Struktur, in der Sie die Mitgliedsvariablen im Geltungsbereich der Struktur manipulieren können. Beachten Sie, dass wir in diesem Beispiel auch das <a href="Instance_Keywords.htm">Schlüsselwort<span class="inline">other</span> </a> verwenden. Dies funktioniert genau wie in einer Instanz bei der Verwendung von <span class="inline">with()</span> und verweist auf die Instanz (oder struct), die den <span class="notranslate">code</span> -Block tatsächlich ausführt.</p>
  <p>Wenn eine Struktur nicht mehr benötigt wird, kann sie mit dem <a href="Language_Features/delete.htm"><span class="inline">delete</span></a> Operator aus dem Speicher entfernt werden, der <span class="notranslate">flags</span> die Struktur für die Garbage Collection freigibt. Dies ist nicht unbedingt erforderlich, da der <a class="glossterm" data-glossterm="Müllsammler" href="#">Garbage Collector</a> dies automatisch tun kann, wenn die Struktur nicht mehr in Ihrer <span class="notranslate">code</span> referenziert wird, aber es ist gute Praxis, dies zu tun, und wir empfehlen es (z. B. rufen Sie <span class="inline">delete</span> im <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">Clean Up-Ereignis</a> einer Instanz auf, um dem Garbage Collector explizit mitzuteilen, dass eine Instanzbereich-Struktur gelöscht werden soll). Hier ist ein Beispiel:</p>
  <p class="code">// Create event<br />
    mystruct =<br />
    {<br />
        pos_x : x,<br />
        pos_y : y,<br />
        count : 1000<br />
    };<br />
    <br />
    // Clean Up event<br />
    delete mystruct;
  </p>
  <h2 id="constr">Konstrukteur-Funktionen</h2>
  <p>Sie können auch <a href="Script_Functions.htm">Skriptfunktionen</a> oder <a href="Method_Variables.htm">-methoden</a> verwenden, um Funktionen zu erstellen, die zur Erzeugung neuer Strukturen verwendet werden können, was die Verwendung des Schlüsselworts <span class="inline">constructor</span> für die Funktion und des <a href="Language_Features/new.htm"><span class="inline">new</span></a> Operator bei der Erstellung einer Struktur aus einer solchen Funktion. Siehe die folgende Funktion:</p>
  <p class="code">function Vector2(_x, _y) <strong>constructor</strong><br />
    {<br />
        x = _x;<br />
        y = _y;<br />
    <br />
        static Add = function(_vec2)<br />
        {<br />
            x += _vec2.x;<br />
            y += _vec2.y;<br />
        }<br />
    }
  </p>
  <p>Oder Sie verwenden die Syntax der Methodenvariablen:</p>
  <p class="code">Vector2 = function(_x, _y) constructor<br />
    {<br />
        x = _x;<br />
        y = _y;<br />
    <br />
        static Add = function(_vec2)<br />
        {<br />
            x += _vec2.x;<br />
            y += _vec2.y;<br />
        }<br />
    }
  </p>
  <p>Hier erstellen wir eine Funktion namens <span class="inline">Vector2</span> und teilen <span data-keyref="GameMaker Name">GameMaker</span> mit, dass es sich dabei um eine Funktion zur Erstellung von Strukturen handelt, indem wir das Schlüsselwort <span class="inline">constructor</span> nach ihrer Definition hinzufügen. Sie können diese Konstruktorfunktion dann wie folgt aufrufen:</p>
  <p class="code">v2 = new Vector2(10, 10);</p>
  <p>Die Variable <span class="inline">v2</span> enthält nun eine Struktur mit den Variablen <span class="inline">x</span> und <span class="inline">y</span> und der <a href="Functions/Static_Variables.htm"><span class="notranslate">static</span></a> <a href="Method_Variables.htm">Methodenvariable</a> <span class="inline">Add</span>.</p>
  <p>Sie können auch optionale <span class="notranslate">arguments</span> in Ihren Konstruktorfunktionen verwenden:</p>
  <p class="code">function Vector2(<strong>_x = 0, _y = 0</strong>) constructor<br />
    {<br />
        x = _x;<br />
        y = _y;<br />
    }</p>
  <p>Dieser Konstruktor verwendet nun <span class="inline">0</span> für die <span class="inline">_x</span> und <span class="inline">_y</span> <span class="notranslate">arguments</span>, wenn sie beim Aufruf der Funktion nicht angegeben werden. Dies bedeutet, dass Sie eine neue <span class="inline">Vector2</span> Struktur erstellen können, ohne Argumente angeben zu müssen:</p>
  <p class="code">empty_vector = new Vector2();</p>
  <h2>Vererbung</h2>
  <p>Funktionen, die auf diese Weise erstellt werden, unterstützen auch die <b>Einzelvererbung</b>, d.h. Sie können eine Konstruktorfunktion erstellen, die Daten von einer anderen Konstruktorfunktion erbt.</p>
  <p class="note"><strong>HINWEIS</strong>: Wenn Sie mit Vererbung arbeiten, können Sie keine Methodenvariablen verwenden, um die Konstruktorfunktion zu definieren, sondern nur <span class="notranslate">script</span> Funktionen.</p>
  <p>Zum Beispiel haben wir oben die Konstruktorfunktion <span class="inline">Vector2</span> erstellt, die wir dann als &quot;Elternteil&quot; für eine andere Konstruktorfunktion verwenden können, die wir <span class="inline">Vector3</span> nennen werden:</p>
  <p class="code">function <strong>Vector3(_x, _y, _z) </strong><strong>:</strong><strong> Vector2(_x, _y) </strong>constructor<br />
    {<br />
        z = _z;<br />
    <br />
        static Add = function( _vec3 )<br />
        {<br />
            x += _vec3.x;<br />
            y += _vec3.y;<br />
            z += _vec3.z;<br />
        }<br />
    }
  </p>
  <p>Wie Sie sehen können, verwenden wir bei der Definition der Funktion einen Doppelpunkt &quot;<span class="inline">:</span>&quot;, um den neuen Konstruktor von dem übergeordneten Konstruktor zu trennen, von dem er geerbt werden soll. Der Child-Konstruktor (<span class="inline">Vector3</span>) übergibt die Variablen <span class="inline">_x</span> und <span class="inline">_y</span> <span class="notranslate">arguments</span> an den Parent-Konstruktor (<span class="inline">Vector2</span>), die dazu verwendet werden, zuerst den Parent-Konstruktor auszuführen und danach den Child-Konstruktor. Auf diese Weise erhält der Child-Konstruktor die Variablen des Parent-Konstruktors (<span class="inline">x</span> und <span class="inline">y</span>) und kann auch seine eigenen definieren (<span class="inline">z</span>).</p>
  <p>Sie können auch konstante Werte an den übergeordneten Konstruktor übergeben, so dass ein bestimmter untergeordneter Konstruktor seinem übergeordneten Konstruktor immer die gleichen Werte liefert:</p>
  <p class="code">function Item(damage) constructor<br />
    {<br />
        my_damage = damage;<br />
    }<br />
    <br />
    function BasicSword() : Item(10) constructor<br />
    {}<br />
    <br />
    var _basic_sword = new BasicSword();<br />
    show_debug_message(_basic_sword.my_damage); // Prints 10
  </p>
  <p>Das bedeutet, dass der Schaden eines einfachen Schwertes immer <span class="inline">10</span> ist, da es diesen Wert an seinen übergeordneten Konstruktor weitergibt, unabhängig davon, wie sein eigener <span class="notranslate">arguments</span> ist.</p>
  <p>Beachten Sie, dass die Zuweisung eines Standardwerts an <span class="notranslate">argument</span> in einem untergeordneten Konstruktor den Standardwert des übergeordneten Konstruktors für diesen <span class="notranslate">argument</span> außer Kraft setzt. Siehe das folgende Beispiel:</p>
  <p class="code">function Parent(value = 10) constructor<br />
    {<br />
        show_debug_message(value);<br />
    }<br />
    <br />
    function Child(value = 20) : Parent(value) constructor<br />
    {<br />
        show_debug_message(value);<br />
    }<br />
    <br />
    var _child = new Child();
  </p>
  <p>Beide Konstruktoren geben <span class="inline">20</span> in das Ausgabeprotokoll aus, da dies der Standardwert für <span class="notranslate">argument</span> war, der vom untergeordneten Konstruktor festgelegt wurde, und derselbe Wert wurde an den übergeordneten Konstruktor übergeben.</p>
  <p>Weitere Informationen zu den Betreibern <span class="inline">new</span> und <span class="inline">delete</span> finden Sie auf den folgenden Seiten:</p>
  <ul class="colour">
    <li><a href="Language_Features/new.htm"><span class="inline">new</span></a></li>
    <li><span class="inline"><a href="Language_Features/delete.htm"><span class="inline">delete</span> </li>
  </ul>
  <h2>String-Ausgabe</h2>
  <p>Ein letzter Punkt, der bei Structs zu erwähnen ist, ist, dass Sie ändern können, was auf der Konsole von ihnen für <span class="notranslate">debugging</span> ausgegeben wird. Standardmäßig gibt der Aufruf der Funktion <a href="../GML_Reference/Debugging/show_debug_overlay.htm"><span class="inline">show_debug_message()</span></a> auf eine Struktur aufruft, wird standardmäßig der Inhalt der Struktur ausgegeben (wie oben gezeigt). Es ist jedoch möglich, diese Meldung anzupassen, indem Sie eine speziell benannte Methode mit dem Namen <span class="inline">toString</span> zu der Struktur hinzufügen:</p>
  <p class="code">mystruct =<br />
    {<br />
        a : 20,<br />
        b : &quot;Hello World&quot;,<br />
    <br />
        toString : function()<br />
        {<br />
            return &quot;This stuct says &quot; + b + &quot;, &quot; + string(a) + &quot; times!&quot;;<br />
        }<br />
    }<br />
    show_debug_message(mystruct);
  </p>
  <p>Wenn nun die Funktion <span class="inline">show_debug_message()</span> aufgerufen wird, wird die Methode <span class="inline">toString</span> verwendet, um die Ausgabe zu generieren, und Sie erhalten - wie im obigen Beispiel - das Ergebnis:</p>
  <p class="code">This struct says Hello World, 20 times!</p>
  <p>Beachten Sie, dass Sie auch die Funktion <a href="../GML_Reference/Strings/Strings.htm"><span class="inline">string()</span></a> Funktion auf eine Strukturreferenz aufrufen und diese verwenden, um den Inhalt - oder die <span class="inline">toString</span> Methode - auf dem Bildschirm anzuzeigen oder in einer Datei zu speichern, oder was auch immer, zum Beispiel:</p>
  <p class="code">var _str = string(mystruct);<br />
    draw_text(32, 32, _str);</p>
  <p>Schließlich gibt es eine Reihe von Laufzeitfunktionen, die Sie auf Structs anwenden können, um die darin enthaltenen Variablen und einige andere Dinge zu erhalten. Sie finden sie im folgenden Abschnitt:</p>
  <ul class="colour">
    <li><a href="../GML_Reference/Variable_Functions/Variable_Functions.htm">Variable Funktionen</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Zurück: <a href="GML_Overview.htm">GML-Übersicht</a></div>
        <div style="float:right">Nächste: <a data-xref="{title}" href="Commenting_Code.htm">Code kommentieren</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Alle Rechte vorbehalten</span></h5>
  </div>
  <!-- KEYWORDS
Structs
struct
constructor
-->
  <!-- TAGS
structs
-->
</body>
</html>