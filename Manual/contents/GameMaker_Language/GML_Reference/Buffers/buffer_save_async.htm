<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>buffer_save_async</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../../assets/css/default.css" type="text/css" />
  <script src="../../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Reference page for buffer_save_async" />
  <meta name="rh-index-keywords" content="buffer_save_async" />
  <meta name="search-keywords" content="buffer_save_async" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>buffer_save_async</h1>
  <p>Mit dieser Funktion können Sie einen Teil des Inhalts von <span class="notranslate">buffer</span> in einer Datei speichern, die Sie dann mit der Funktion <a href="buffer_load.htm"><span class="inline">buffer_load()</span></a> Funktion (oder einer der anderen Funktionen zum Laden von <span class="notranslate">buffers</span>) wieder in den Speicher eingelesen werden kann. Der &quot;Offset&quot; definiert die Startposition innerhalb der <span class="notranslate">buffer</span> für die Speicherung (in Bytes), und die &quot;Größe&quot; ist die Größe des <span class="notranslate">buffer</span> Bereichs, der von diesem Offset an gespeichert werden soll (ebenfalls in Bytes). Diese Funktion arbeitet asynchron, d.h. das Spiel läuft weiter, während gespeichert wird, und alle Dateien, die mit dieser Funktion gespeichert werden, werden in einem &quot;Standard&quot;-Ordner abgelegt. Dieser Ordner muss <i>nicht</i> in den Dateinamen aufgenommen werden, da er automatisch von <span class="notranslate">GameMaker</span> hinzugefügt wird. Zum Beispiel würde der Dateipfad &quot;<span class="inline">Data\Player_Save.sav</span>&quot; tatsächlich unter &quot;<span class="inline">default\Data\Player_Save.sav</span>&quot; gespeichert werden. Wenn Sie die Datei dann jedoch mit der Funktion <a href="buffer_load_async.htm"><span class="inline">buffer_load_async()</span></a>laden, müssen Sie den &quot;Standard&quot;-Teil des Pfades ebenfalls nicht angeben (aber jede andere Dateifunktion benötigt ihn, außer auf den Konsolen Xbox One, PS4 und <span class="notranslate">Nintendo</span> <span class="notranslate">Switch</span>).</p>
  <p class="note"><b>HINWEIS</b>: Bei HTML5 wird &quot;default/&quot; nicht automatisch hinzugefügt und Sie müssen dies möglicherweise in Ihrem <span class="notranslate">code</span> berücksichtigen.</p>
  <p>Die Funktion gibt einen eindeutigen ID-Wert zurück und löst ein <a href="../../../The_Asset_Editors/Object_Properties/Async_Events/Save_Load.htm">asynchrones Speichern/Laden-Ereignis</a> aus, bei dem Sie die zurückgegebene ID verwenden können, um den <span class="inline">async_load</span> ID-Wert zu überprüfen, wie im folgenden erweiterten Beispiel gezeigt. Die <a href="../../GML_Overview/Variables/Builtin_Global_Variables/async_load.htm"><span class="inline">async_load</span></a> Map im Ereignis enthält die folgenden zwei Schlüssel/Wertpaare:</p>
  <ul>
    <li>&quot;<b>id&quot;: </b>die ID der asynchronen Funktion, wie sie von der Speicherfunktion zurückgegeben wird.</li>
    <li>&quot;<b>status&quot;: </b>gibt <span class="inline">true</span> zurück, wenn die Daten korrekt gespeichert/geladen wurden, und andernfalls <span class="inline">false</span>.</li>
  </ul>
  <p>Beachten Sie, dass Sie mehrere <span class="notranslate">buffers</span> in einem speichern können, indem Sie diese Funktion mehrmals zwischen den Aufrufen von <a href="buffer_async_group_begin.htm"><span class="inline">buffer_async_group_begin()</span></a> und <a href="buffer_async_group_end.htm"><span class="inline">buffer_async_group_end()</span></a> aufrufen (siehe diese Funktionen für weitere Informationen).</p>
  <p class="note"><b>HINWEIS</b>: Bei HTML5 werden die zurückgegebenen Ergebnisse als base64-kodierte Zeichenketten gespeichert, wenn sie in einer Datei gespeichert werden.</p>
  <p> </p>
  <h4>Syntax:</h4>
  <p class="code">buffer_save_async(buffer, filename, offset, size);</p>
  <table>
    <tbody>
      <tr>
        <th>Argument</th><th>Typ</th>
        <th>Beschreibung</th>
     </tr>
      <tr>
        <td><span class="notranslate">buffer</span></td><td><span data-keyref="Type_ID_Buffer"></span></td>
        <td><span class="notranslate">The index of the buffer to save.</span></td>
     </tr>
      <tr>
        <td><span class="notranslate">filename</span></td><td><span data-keyref="Type_String"></span></td>
        <td><span class="notranslate">The name of the file to save as.</span></td>
     </tr>
      <tr>
        <td><span class="notranslate">offset</span></td><td><span data-keyref="Type_Real"></span></td>
        <td><span class="notranslate">The offset within the buffer to save from (in bytes).</span></td>
     </tr>
      <tr>
        <td><span class="notranslate">size</span></td><td><span data-keyref="Type_Real"></span></td>
        <td><span class="notranslate">The size of the buffer area to save (in bytes).</span></td>
     </tr>
    </tbody>
  </table>
  <p> </p>
  <h4>Rückgabe:</h4>
  <p class="code"><span data-keyref="Type_ID_Async_Event">Async Request ID</span></p>
  <p> </p>
  <h4>Erweitertes Beispiel:</h4>
  <p>Die Funktion <span class="inline">buffer_save_async()</span> kann von jedem Ereignis aus aufgerufen werden, und da sie asynchron ist, kann der Rückruf fast sofort erfolgen oder mehrere Sekunden dauern. Der Aufruf der Funktion ist einfach und würde etwa so aussehen:</p>
  <p class="code">saveid = buffer_save_async(buff, &quot;Player_Save.sav&quot;, 0, 16384);</p>
  <p>Die obige <span class="notranslate">code</span> speichert den Inhalt der <span class="notranslate">buffer</span> &quot;<i>buff</i>&quot; in der angegebenen Speicherdatei und speichert die ID des Funktionsaufrufs in der Variablen &quot;<i>saveid</i>&quot;. Wenn die Speicherung abgeschlossen ist, wird das asynchrone Save/Load-Ereignis ausgelöst, und Sie können die <span class="inline">async_load</span> Map nach der korrekten ID der Funktion analysieren, etwa so:</p>
  <p class="code">if ds_map_find_value(async_load, &quot;id&quot;) == saveid<br />
    {<br />
        if ds_map_find_value(async_load, &quot;status&quot;) == false<br />
        {<br />
            show_debug_message(&quot;Save failed!&quot;);<br />
        }<br />
    }</p>
  <p>Die obige <span class="notranslate">code</span> prüft zunächst die ID der erstellten DS-Map, dann den Status des Rückrufs und gibt eine Debug-Meldung aus, wenn Probleme aufgetreten sind.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Zurück: <a href="Buffers.htm">Puffer</a></div>
        <div style="float:right">Nächste: <a href="buffer_load.htm"><span class="notranslate">buffer_load</span></a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Alle Rechte vorbehalten</span></h5>
  </div>
  <!-- KEYWORDS
buffer_save_async
-->
  <!-- TAGS
buffer_save_async
-->
</body>
</html>