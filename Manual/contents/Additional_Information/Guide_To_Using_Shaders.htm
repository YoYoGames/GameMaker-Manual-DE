<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Anleitung zur Verwendung von Shadern</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how to set up and use shaders" />
  <meta name="rh-index-keywords" content="Guide To Using Shaders" />
  <meta name="search-keywords" content="shaders,shader,use shaders,shader guide,shader setup,shader examples,shader example" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Anleitung zur Verwendung von Shadern</h1>
  <p>Shader werden oft verwendet, um schöne grafische Effekte in Spielen zu erzeugen. Sie gehören auch zu den fortschrittlichsten Funktionen, die <span data-keyref="GameMaker Name">GameMaker</span> bietet. Daher ist es notwendig, dass Sie ein grundlegendes Verständnis der Programmierung und der Funktionsweise von <span data-keyref="GameMaker Name">GameMaker</span> haben, bevor Sie damit beginnen.</p>
  <p>Was also ist ein Shader? Ursprünglich wurden sie entwickelt, um Schattierungen für die Beleuchtung zu erzeugen (daher der Name), aber inzwischen werden sie für eine Vielzahl von Effekten verwendet. Shader <span class="notranslate">code</span> ähnelt dem normalen <span class="notranslate">code</span>, wird aber (fast immer) von der GPU und nicht von der CPU ausgeführt. Dieser Unterschied bringt eine Reihe von Regeln und Einschränkungen mit sich, auf die wir später noch eingehen werden.</p>
  <p>Jeder Shader besteht aus zwei separaten Komponenten: einem <strong>Vertex-Shader </strong>und einem <strong>Fragment-Shader </strong>(auch als <strong>Pixel-Shader</strong> bezeichnet). Beginnen wir mit dem Vertex-Shader. Jedes <span class="notranslate">sprite</span> wird durch ein Rechteck gebildet, aber Computer zeichnen gerne Dreiecke, also werden diese Rechtecke in zwei Dreiecke aufgeteilt (manchmal als <em>Quad</em> bezeichnet). Damit bleiben sechs Eckpunkte (Ecken) pro <span class="notranslate">sprite</span> übrig, aber zwei davon sind die gleichen, so dass wir uns nur um vier kümmern müssen. Stellen Sie sich nun vor, dass wir eine for <span class="notranslate">loop</span> haben, die über jeden Scheitelpunkt geht und die <span class="notranslate">code</span> innerhalb des Vertex-Shaders für jeden ausführt. Dadurch können wir die Position und die Farbe des Scheitelpunkts ändern, bevor wir ihn an den Fragment-Shader weitergeben, da der Vertex-Shader früher ausgeführt wird.</p>
  <p>Das würde folgendermaßen aussehen:</p>
  <p><img>Für den Fragment-Shader können Sie sich dieselbe <span class="notranslate">loop</span> wie zuvor vorstellen, aber diesmal geht er über jedes einzelne Pixel in Ihrem <span class="notranslate">sprite</span> und gibt Ihnen Informationen wie die Position und Farbe dieses Pixels. In Ihrem Fragment-Shader <span class="notranslate">code</span> führen Sie Operationen und Berechnungen durch, um die Farbe dieses Pixels zu bestimmen und den gewünschten Effekt zu erzielen. Wenn Sie z. B. möchten, dass Ihr <span class="notranslate">sprite</span> schwarz-weiß ist, müssen Sie berechnen, welchen Grauton jedes Pixel haben muss, um den Effekt zu erzielen.</p>
  <p>Sie würde etwa so aussehen:</p>
  <p><img>Der Grund dafür, dass Shader <span class="notranslate">code</span> in der Regel von der GPU ausgeführt werden, liegt darin, dass sie dabei effizienter sind. Moderne CPUs haben in der Regel zwischen zwei und acht Kerne. Jeder Kern kann jeweils eine Aufgabe ausführen. Wenn wir also die Vorteile mehrerer Kerne nutzen, können wir so viele Aufgaben gleichzeitig ausführen. Im Gegensatz dazu können moderne GPUs Tausende oder sogar Zehntausende von Aufgaben gleichzeitig ausführen. Dies ist für Shader hilfreich, da wir den Shader <span class="notranslate">code</span> von Tausenden von Pixeln gleichzeitig ausführen können. Die Einschränkung besteht darin, dass wir nur Zugriff auf den Anfangszustand des <span class="notranslate">sprite</span> haben, so dass wir nicht wissen, welche Änderungen an anderen Pixeln vorgenommen wurden, da wir nicht sicher sein können, dass der <span class="notranslate">code</span> bereits auf ihnen ausgeführt wurde.</p>
  <p class="note"><strong>HINWEIS</strong>: Mit <span data-keyref="GameMaker Name">GameMaker</span> können Shader in <strong>GLSL</strong> (OpenGL Shader Language), <strong>HLSL</strong> (High-Level Shader Language, die bei der Arbeit mit DirectX verwendet wird) und <strong>GLSL ES</strong> (eine Untergruppe von GLSL, die in mobilen Geräten üblich ist) geschrieben werden. Hier verwenden wir <strong>GLSL ES</strong> als Shader-Sprache, da sie die beste Kompatibilität zwischen den Zielsystemen bietet <span class="notranslate">platforms</span>. Im Allgemeinen sollten Sie diese Sprache immer verwenden, es sei denn, Sie haben sehr spezielle Anforderungen und verstehen die Einschränkungen der anderen Shader-Sprachen. Die Mathematik und die Techniken sollten jedoch bei allen drei Sprachen ähnlich sein, abgesehen von ein paar <span class="notranslate">syntax</span> Unterschieden hier und da.</p>
  <p>Der Vertex-Shader wird zuerst ausgeführt und befasst sich, wie oben erläutert, mit den <strong>Scheitelpunkten</strong>. Er wird verwendet, um Positionen, Normalen und Texturkoordinaten zu berechnen. Diese Shader sind in 2D nicht besonders nützlich, da jedes <span class="notranslate">sprite</span> in der Regel ein Quadrat ist, aber sie können verwendet werden, um einige Verzerrungen, Skalierungen, etc. durchzuführen. In 3D sind sie viel nützlicher für Beleuchtungsberechnungen und Mesh-Verformungen. Fragment-Shader sind viel interessanter und werden hier hauptsächlich behandelt, da wir mit dem Fragment-Shader Informationen über unsere Texturen erhalten und die endgültige Farbe jedes Pixels in unserem Bild verändern können.</p>
  <p> </p>
  <h2>Shader-Variablen</h2>
  <p>Wenn Sie einen Shader in <span data-keyref="GameMaker Name">GameMaker</span> erstellt haben, haben Sie vielleicht die folgenden Schlüsselwörter im <strong>Standard-Pass-Through-Shader</strong> bemerkt. Diese Schlüsselwörter helfen dem Shader, den Zweck und den Umfang der einzelnen Variablen zu verstehen:</p>
  <ul class="colour">
    <li><strong>Attribut</strong>: Dies sind Variablen, die von OpenGL an den <strong>Vertex-Shader </strong>übergeben werden. Sie können sich pro Scheitelpunkt ändern und sind schreibgeschützt. Dazu gehören Informationen wie Scheitelpunktposition, Texturkoordinaten, Scheitelfarbe und Scheitelnormal.</li>
    <li><strong>Variierend</strong>: Dies sind Variablen, die zur Übermittlung von Daten zwischen dem <strong>Vertex- </strong>und dem <strong>Fragment-Shader </strong>verwendet werden. Sie können im Vertex-Shader geschrieben werden, sind aber im Fragment-Shader schreibgeschützt.</li>
    <li><strong>Einheitlich</strong>: Dies sind Variablen, die sich pro Objekt ändern und vom Benutzer an den Shader übergeben werden. Sie können sowohl im Vertex- als auch im Fragment-Shader verwendet werden, sind aber schreibgeschützt.</li>
  </ul>
  <p>Sie werden auch die Verwendung von <strong>vec</strong> als Schlüsselwort sehen. Dies wird verwendet, um eine <span class="notranslate">vector</span> Variable im Shader zu identifizieren, und Sie werden bald sehen, dass Vektoren bei der Arbeit mit Shadern sehr wichtig sind. Aus diesem Grund sind sie als Basistyp in GLSL implementiert. Wenn Sie mit ihnen nicht vertraut sind, handelt es sich um einen mathematischen Begriff, der als Matrix mit nur einer Spalte dargestellt wird. In der Programmierung stellen wir sie normalerweise als Array dar, wobei die Anzahl der Komponenten der Dimension entspricht. Zwei- und dreidimensionale <span class="notranslate">vectors</span> werden oft für Positionen, Texturkoordinaten oder Farben ohne Alphakanal verwendet, während vierdimensionale für Farben mit Alphakanal verwendet werden. Wir können auch angeben, ob sie Boolesche Werte, Ganzzahlen oder Fließkommazahlen enthalten. Die <span class="notranslate">syntax</span>, um eine <span class="notranslate">vector</span> zu deklarieren, ist die folgende:</p>
  <p class="code">vec2 firstVec;  // Two-dimensional vector of floats<br />
    vec3 secondVec; // Three-dimensional vector of floats<br />
    vec4 thirdVec;  // Four-dimensional vector of floats<br />
    <br />
    bvec3 boolVec;  // Three-dimensional vector of booleans<br />
    ivec4 intVec;   // Four-dimensional vector of integers
  </p>
  <p>Um sie zu initialisieren, können wir den Konstruktor verwenden, um die <span class="notranslate">vector</span> zu erstellen. Sie müssen die gleiche Anzahl von Werten wie die Länge der <span class="notranslate">vector</span> angeben, aber Sie können Skalare und kleinere <span class="notranslate">vectors</span> mischen und anpassen, um die Ziellänge zu erreichen. Hier sind einige Beispiele dafür:</p>
  <p class="code">// Simple 2D vector with 2 scalar values<br />
    vec2 firstVec  = vec2(2.0, 1.0);<br />
    // A 4D vector using 2 scalars and a vec2 create the 4 values<br />
    vec4 secondVec = vec4(1.0, firstVec, 0.0);<br />
    // A 3D vector using 1 component of a vec4 plus a vec2 to create the 3 values<br />
    vec3 thirdVec  = vec3(secondVec.x, firstVec);</p>
  <p>Wir können ihnen auch eine andere <span class="notranslate">vector</span> mit der gleichen Länge zuweisen (oder die <span class="notranslate">vector</span> so lange <em>tauschen </em>, bis sie die richtige Länge hat, aber das werden wir gleich erklären):</p>
  <p class="code">vec3 firstVec;<br />
    vec3 secondVec = firstVec;<br />
    vec4 thirdVec  = secondVec.xyz;<br />
    vec2 fourthVec = thirdVec.zx;</p>
  <p>Für den Zugriff auf die Komponenten von <span class="notranslate">vector</span> in GLSL gibt es mehrere Möglichkeiten. Die einfachste besteht darin, <span class="notranslate">vector</span> als Array zu behandeln und auf die Komponenten mit eckigen Klammern zuzugreifen, etwa so:</p>
  <p class="code">vec4 myVec;<br />
    myVec[0] = 0.0;<br />
    myVec[1] = 1.0;<br />
    myVec[2] = 2.0;<br />
    myVec[3] = 1.0;</p>
  <p>Es gibt jedoch eine andere Möglichkeit, auf die Komponenten mit der folgenden Syntax zuzugreifen:</p>
  <p class="code">vec4 myVec;<br />
    myVec.x = 1.0;<br />
    myVec.y = 2.0;</p>
  <p>Dabei werden die Komponentennamen innerhalb von <span class="notranslate">vector</span> verwendet, um auf sie zuzugreifen. Sie können x, y, z oder w verwenden, um die erste, zweite, dritte bzw. vierte Komponente zu erhalten. Wir bezeichnen diese Methode als " <strong>Swizzling" </strong>, weil die folgende <span class="notranslate">syntax</span> ebenfalls gültig ist:</p>
  <p class="code">vec4 firstVec;<br />
    vec3 secondVec = firstVec.xyz;<br />
    vec2 thirdVec  = secondVec.zy;<br />
    vec4 fourthVec = thirdVec.yxxy;</p>
  <p>Wie Sie sehen, können wir eine beliebige Kombination von bis zu vier Buchstaben verwenden, um ein <span class="notranslate">vector</span> dieser Länge zu erstellen. Es kann nicht versucht werden, auf eine Komponente zuzugreifen, die nicht zulässig ist (z. B. der Versuch, auf w in <span class="inline">secondVec</span> oder <span class="inline">thirdVec</span> zuzugreifen, da diese keine vierte Komponente haben). Außerdem können wir Buchstaben wiederholen und in beliebiger Reihenfolge verwenden, solange die Variable <span class="notranslate">vector</span>, der sie zugewiesen wird, die gleiche Größe wie die Anzahl der verwendeten Buchstaben hat.</p>
  <p>Aus offensichtlichen Gründen können Sie bei der Verwendung von swizzle zum Festlegen von Komponentenwerten nicht dieselbe Komponente zweimal verwenden. Das folgende Beispiel ist nicht gültig, da Sie versuchen, dieselbe Komponente auf zwei verschiedene Werte zu setzen:</p>
  <p class="code">myVec.xx = vec2(2.0, 3.0);</p>
  <p>Zuletzt haben wir <span class="inline">xyzw</span> als Swizzle-Maske verwendet, was normalerweise der Fall ist, wenn wir mit Positionen arbeiten. Es gibt zwei weitere Maskensätze, die Sie verwenden können: <span class="inline">rgba</span> (für Farben) oder <span class="inline">stpq</span> (für Texturkoordinaten). Intern gibt es keinen Unterschied zwischen diesen Masken, und wir verwenden sie nur, um <span class="notranslate">code</span> deutlicher zu machen, was <span class="notranslate">vector</span> in diesem Fall darstellt. Außerdem können wir Swizzle-Masken nicht in der gleichen Operation kombinieren, daher ist dies ungültig:</p>
  <p class="code"><span class="inline"></span>myVec = otherVec.ybp;</p>
  <p>Das waren eine Menge Definitionen und Informationen, aber die Kenntnis dieser Dinge ist notwendig, um Shader selbst zu verstehen.</p>
  <p> </p>
  <h2>Einen Shader erstellen</h2>
  <p>Wenn Sie einen Shader in <span data-keyref="GameMaker Name">GameMaker</span> erstellen, werden zwei Dateien für Sie geöffnet: ein Vertex-Shader (<span class="inline">.vsh</span>) und ein Fragment-Shader (<span class="inline">.fsh</span>). Dies ist der einfachste Shader, den Sie erstellen können. Er nimmt eine <span class="notranslate">sprite</span>, liest die Textur und färbt jedes Pixel mit dieser Farbe. Wenn Sie beim Zeichnen Scheitelfarben angeben, werden diese Farben mit der Textur vermischt.</p>
  <p>Gehen wir nun die <span class="notranslate">code</span> für ein neu erstelltes Shader-Asset durch und analysieren es, beginnend mit dem Vertex-Shader.</p>
  <p class="code">// Passthrough Vertex Shader<br />
    attribute vec3 in_Position;                  // (x,y,z)<br />
    //attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader.<br />
    attribute vec4 in_Colour;                    // (r,g,b,a)<br />
    attribute vec2 in_TextureCoord;              // (u,v)<br />
    <br />
    varying vec2 v_vTexcoord;<br />
    varying vec4 v_vColour;<br />
    <br />
    void main()<br />
    {<br />
        vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);<br />
        gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;<br />
        <br />
        v_vColour = in_Colour;<br />
        v_vTexcoord = in_TextureCoord;<br />
    }
  </p>
  <p>Außerhalb der Hauptfunktion sehen wir einige Variablendeklarationen und ihre Qualifier. Die Attribute werden uns von <span class="notranslate">GameMaker</span> zur Verfügung gestellt. Die variablen Attribute werden vom Benutzer erstellt, um diese Informationen an den Fragment-Shader weiterzugeben. Innerhalb der Hauptfunktion werden die Berechnungen zur Ermittlung der Bildschirmposition des Scheitelpunkts durchgeführt:</p>
  <ul class="colour">
    <li>Zunächst erstellen wir ein <span class="inline">vec4</span> und initialisieren es mit den Komponenten der Position, wobei wir eine Eins als vierte Komponente hinzufügen. In der linearen Algebra ist es üblich, dass wir der vierten Komponente eine Eins hinzufügen, wenn <span class="notranslate">vector</span> einen Punkt darstellt, oder eine Null, wenn es einen tatsächlichen <span class="notranslate">vector</span> darstellt.</li>
    <li>Als Nächstes müssen wir diese vierte Komponente hinzufügen, um sie mit der <span class="inline">MATRIX_WORLD_VIEW_PROJECTION</span> Matrix zu multiplizieren, die eine 4x4 Matrix ist. Durch diese Multiplikation wird die Position des Scheitelpunkts in Bildschirmkoordinaten umgerechnet.</li>
    <li>Schließlich übergeben wir die Scheitelfarbe und die Texturkoordinaten an den Fragment-Shader durch unsere verschiedenen Variablen.</li>
  </ul>
  <p>Dieser Shader sollte in Ruhe gelassen werden, wenn Sie nicht vorhaben, mit Vertex-Positionen zu spielen, und er wird in keinem der folgenden Beispiele verwendet, da alle gezeigten Effekte mit dem Fragment-Shader erzeugt werden.</p>
  <p>Werfen wir nun einen kurzen Blick auf den Fragment-Shader:</p>
  <p class="code">// Passthrough Fragment Shader<br />
    varying vec2 v_vTexcoord;<br />
    varying vec4 v_vColour;<br />
    <br />
    void main()<br />
    {<br />
        gl_FragColor = v_vColour * texture2D( gm_BaseTexture, v_vTexcoord );<br />
    }
  </p>
  <p>Wie bereits erläutert, besteht die Idee hinter einem Fragment-Shader darin, die Farbe des aktuellen Pixels zurückzugeben. Dies geschieht, indem der Variablen <span class="inline">gl_FragColor</span> der endgültige Farbwert zugewiesen wird. Die Funktion <span class="inline">texture2D</span> nimmt eine Textur und eine <span class="inline">vec2</span> mit den UV-Koordinaten, die Sie in dieser Textur überprüfen möchten, und gibt eine <span class="inline">vec4</span> mit der Farbe zurück. Im Pass-Through-Shader wird lediglich die Farbe der Textur in der Koordinate dieses Pixels erfasst und mit der Farbe des diesem Pixel zugeordneten Vertex multipliziert.</p>
  <p>Nun, da wir unseren ersten Shader haben, müssen wir zum Testen nur noch ein Objekt erstellen und ihm eine <span class="notranslate">sprite</span> zuweisen, und dann im <strong>Draw Event</strong> des Objekts den Shader wie folgt einstellen:</p>
  <p class="code">// Draw Event<br />
    shader_set(shdrColorOverlay);<br />
    draw_self();<br />
    shader_reset();</p>
  <p>Jeder Unentschieden-Aufruf, den wir zwischen <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_set.htm"><span class="inline">shader_set()</span></a> und <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_reset.htm"><span class="inline">shader_reset()</span></a> wird der Shader auf ihn angewendet. Hier zeichnen wir das Objekt <span class="notranslate">sprite</span> mit unserem Passthrough-Shader:</p>
  <p><img>Wie Sie vielleicht schon vermutet haben, ändert sich dadurch visuell nichts, da es sich um einen einfachen Pass-Through-Shader handelt. In den folgenden Abschnitten werden jedoch einige einfache Schritte beschrieben, die Sie vornehmen können, um dies zu ändern und die Art und Weise, wie <span class="notranslate">sprite</span> gezeichnet wird, zu verändern. Jeder der Abschnitte zeigt einen anderen Shader, den Sie erstellen und in Ihren Projekten verwenden können, und erklärt die Schritte, die zur Erstellung erforderlich sind, und warum wir die Dinge so machen, wie wir sie machen.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Farbüberlagerungs-Shader</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Wir können jetzt den Basis-Shader bearbeiten, um etwas anderes zu tun. Wir werden den Vertex-Shader-Teil nicht anfassen und nur den Fragment-Shader bearbeiten, und zu Beginn werden wir eine sehr einfache Operation durchführen, nämlich den Shader dazu bringen, die <span class="notranslate">sprite</span> mit der Farbe Rot zu zeichnen. Wir tun dies, indem wir einfach die <span class="inline">gl_FragColor</span> in rot ändern, etwa so:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      void main()<br />
      {<br />
          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);<br />
      }</p>
    <p class="dropspot">Daraus ergibt sich das folgende Ergebnis:</p>
    <p class="dropspot"><img>Nicht gerade das, was wir erwartet haben! Wir müssen bedenken, dass jedes <span class="notranslate">sprite</span> letztlich ein Rechteck ist. Wenn wir also keine Transparenz berücksichtigen - was wir nicht getan haben -, ist das das Ergebnis, das wir erhalten.</p>
    <p class="note"><strong>HINWEIS</strong>: Im obigen Bild ändert sich die Größe des Rechtecks, weil der &quot;leere&quot; Raum um die Basis <span class="notranslate">sprite</span> automatisch beschnitten wurde, als sie von <span class="notranslate">GameMaker</span> auf der Texturseite platziert wurde, so dass die Dreiecke, aus denen es besteht, bei jedem Animationsbild eine andere Größe haben, um in die beschnittene Größe des Bildes zu passen. Wenn Sie diese Option deaktivieren, haben Sie einfach ein unbewegliches rotes Quadrat auf dem Bildschirm.</p>
    <p class="dropspot">Oben haben wir die Funktion <span class="inline">texture2D</span> erwähnt, mit der wir die Farbe des Pixels, an dem wir gerade arbeiten, erfassen und die Transparenz daraus ableiten. Der Rückgabewert von <span class="inline">texture2D</span> ist ein <span class="inline">vec4</span>, wobei die Komponenten Rot, Grün, Blau und Alpha in dieser Reihenfolge sind. Wir können auf den Alphakanal zugreifen, indem wir entweder einen Punkt gefolgt von einem <span class="inline">a</span> oder einem <span class="inline">w</span> hinter den Variablennamen setzen. Dies entspricht RGBA bzw. XYZW.</p>
    <p class="dropspot">Hier ist der aktualisierte Code:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          gl_FragColor = vec4(1.0, 0.0, 0.0, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Wir weisen nun <span class="inline">gl_FragColor</span> eine neue <span class="inline">vec4</span> zu, bei der der Rot-Kanal maximal, der Grün- und Blau-Kanal gleich Null und der Alpha-Kanal derselbe wie bei der Originaltextur ist. Die Ausgabe sieht wie folgt aus:</p>
    <p class="dropspot"><img>Das war es, was wir wollten! Wir haben die Farbe eines jeden Pixels durch Rot ersetzt, aber den Alphakanal intakt gelassen.</p>
    <p class="dropspot">Den Shader jedes Mal zu ändern, wenn wir eine andere Farbe verwenden wollen, ist keine gute Idee, zumal wir für jede gewünschte Farbe einen eigenen Shader benötigen würden. Stattdessen werden wir die Farbinformationen über eine <strong>Uniform</strong> an den Shader weitergeben. Dazu müssen wir uns zunächst einen <strong>Zeiger </strong>auf die Uniform besorgen. Wir werden dies im <strong>Create-Event</strong> unseres Objekts tun, das die <span class="notranslate">sprite</span> hat, indem wir hinzufügen:</p>
    <p class="code">// Create Event<br />
      _uniColor = shader_get_uniform(shdrColorOverlay, &quot;u_colour&quot;);<br />
      _color    = [1.0, 1.0, 0.0, 1.0];</p>
    <p class="dropspot">Alles, was wir tun müssen, ist den Aufruf <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_get_uniform.htm"><span class="inline">shader_get_uniform()</span></a> aufzurufen, um einen Zeiger auf die Uniform zu erhalten. Die Parameter, die wir übergeben müssen, sind der Name des Shader-Assets (ohne Anführungszeichen, weil wir die ID übergeben wollen, die <span class="notranslate">GameMaker</span> für uns generiert) und der Name der Uniform-Variable innerhalb des Shaders, diesmal als String. Dieser Name muss genau mit dem Namen im Shader <span class="notranslate">code</span> übereinstimmen, damit er funktioniert. Wir haben auch eine Farbvariable hinzugefügt, damit wir sie unter <span class="notranslate">runtime</span> ändern können und sie sich unsere Änderungen merkt.</p>
    <p class="dropspot">Jetzt wird die <span class="notranslate">code</span> in unserem Draw-Ereignis leicht geändert, um die einheitliche Variable zu übergeben.</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrColorOverlay);<br />
      shader_set_uniform_f_array(_uniColor, _color);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Es ist die gleiche <span class="notranslate">code</span> wie zuvor, aber bevor wir etwas zeichnen, müssen wir alle einheitlichen Werte an den Shader übergeben. In diesem Fall übergeben wir die Farbe als ein Array von Floats. Was den Shader betrifft, so werden wir ihn so ändern, dass er die Uniform einschließt und verwendet, also wird er:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      uniform vec4 u_color;<br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          gl_FragColor = vec4(u_color.rgb, texColor.a);<br />
      }</p>
    <p class="dropspot">Wir deklarieren eine Variable mit dem gleichen Namen wie im Create-Shader (<span class="inline">u_color</span>) und übergeben sie als die ersten drei Komponenten des <span class="inline">gl_FragColor</span> <span class="notranslate">vector</span>, wobei wir die Vorteile des Swizzling nutzen. Wenn wir erneut kompilieren, sollten wir dies sehen:</p>
    <p class="dropspot"><img>Jetzt ist der Shader viel nützlicher und wiederverwendbar. Es liegt an Ihnen, mehr Funktionalität hinzuzufügen, wenn Sie es brauchen, um die Farbe (mit der Variable <span class="inline">_color</span>) während <span class="notranslate">runtime</span> zu setzen.</p>
    <p> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Schwarzer und weißer Shader</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Die Erstellung eines Schwarz-Weiß-Shaders ist ein guter Weg, um mehr über die Funktionsweise von Shadern zu erfahren, und viele Anfänger beginnen mit diesem Versuch, da er konzeptionell recht einfach ist: Erfassen Sie jedes Pixel und weisen Sie ihm einen Grauton zu. Aber ist es wirklich so einfach? Nicht ganz...</p>
    <p class="dropspot">Wenn bei der Verwendung von RGB-Farben alle drei Komponenten den gleichen Wert haben, erhalten wir einen Grauton. Die naive Herangehensweise bei der Erstellung eines Shaders, der diese Idee nutzt, wäre, alle drei Farbkanäle (Rot, Grün und Blau) zu addieren und dann durch drei zu dividieren. Danach würde man den Wert allen drei Kanälen zuweisen und so einen Grauton erzeugen. So sieht dieser Fragment-Shader aus:</p>
    <p class="code">// Black and white fragment shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          float gray = (texColor.r + texColor.g + texColor.b) / 3.0;<br />
          gl_FragColor = v_vColour * vec4(gray, gray, gray, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Eine Sache, die Sie vielleicht bemerkt haben, ist, dass wir in <span class="inline">gl_FragColor</span> <span class="notranslate">code</span> die <span class="inline">vec4</span> mit etwas namens <span class="inline">v_vColour</span> multiplizieren. Dabei handelt es sich um eine vom Vertex-Shader übergebene Variable, die uns die Farbe des mit diesem Pixel verbundenen Vertex angibt. Es ist immer eine gute Idee, die endgültig berechnete Farbe mit der Scheitelfarbe zu multiplizieren. In den meisten Fällen wird dies nichts bewirken, aber wenn Sie die Scheitelfarbe in <span class="notranslate">GML</span> geändert haben, wird dies widergespiegelt (indem Sie Funktionen wie <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_ext.htm"><span class="inline">draw_sprite_ext()</span></a> oder <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_general.htm"><span class="inline">draw_sprite_general()</span></a> zum Ändern der <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_blend.htm"><span class="inline">image_blend</span></a>).</p>
    <p class="dropspot">Was die Auslosung betrifft, so ist sie recht einfach, da wir keine Uniform zum Übergeben haben:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrBlackAndWhite);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Lassen Sie uns kompilieren und sehen, was wir haben.</p>
    <p class="dropspot"><img>Das sieht doch schon toll aus, oder? Nun, ja und nein... es gibt eine Lösung, die "korrekter" ist, denn anstatt die Komponenten zu addieren und durch drei zu teilen, multiplizieren wir jede Komponente mit den Standard-NTSC-Werten für Schwarz und Weiß. Hier ist der geänderte Fragment-Shader-Code:</p>
    <p class="code">// Black and white fragment shader<br />
      varying vec2 v_vTexcoord;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));<br />
          gl_FragColor = vec4(gray, gray, gray, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Wir verwenden das Punktprodukt als Abkürzung für die Multiplikation der einzelnen Komponenten von <span class="inline">texColor</span> mit den richtigen Gewichten und addieren sie dann zusammen. Wenn Sie mit dem Punktprodukt nicht vertraut sind, ist dies im Wesentlichen das, was passiert:</p>
    <p class="code">float gray = (texColor.r * 0.299) + (texColor.g * 0.587) + (texColor.b * 0.114);</p>
    <p class="dropspot">Im Endeffekt sieht es sehr ähnlich aus, ist aber technisch korrekter.</p>
    <p class="dropspot"><img alt="Shader Vertices" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Vertices.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Regenbogen-Shader</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Unser letztes Shader-Beispiel ist sehr unterhaltsam und kann verwendet werden, um Text, Schaltflächen und anderen Dingen Leben einzuhauchen. Wir fangen einfach an und fügen nach und nach Funktionen hinzu, da dieser Shader sehr anpassbar ist. Es gibt eine ganze Menge zu behandeln, wenn Sie sich also etwas verloren oder verwirrt fühlen, gehen Sie bitte zurück und lesen Sie einige der obigen Abschnitte erneut.</p>
    <p class="dropspot">Als erstes wollen wir die Pixel mit jedem Farbton einfärben, abhängig von der horizontalen Position des Pixels. Dazu müssen wir die x-Position als Farbton festlegen und dann vom HSV-Format (Farbton, Sättigung, Helligkeit) in das RGB-Format (Rot, Grün und Blau) konvertieren. Dazu müssen wir eine Hilfsfunktion in unserem Fragment-Shader schreiben, die HSV-Werte annimmt und ein RGB zurückgibt <span class="notranslate">vector</span>. Wir werden eine einzige Funktion verwenden, die dies ohne <span class="inline">if</span> Anweisungen erledigt, da die Verwendung von Bedingungen in Shadern <span class="notranslate">code</span> Shader <em>sehr </em>langsam macht und daher vermieden werden sollte.</p>
    <p class="dropspot">So sieht der Shader in diesem Stadium aus:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          vec3 col = vec3(v_vTexcoord.x, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Hier ist ein bisschen mehr los als in den vorherigen Beispielen, aber das meiste sollte Ihnen jetzt klar sein. Zunächst ist da unsere Funktion <span class="inline">hsv2rgb</span>, die eine <span class="inline">vec3</span> mit unserer HSV-Farbe aufnimmt und eine weitere <span class="inline">vec3</span> mit unserer RGB-Konvertierung zurückgibt. In der Hauptfunktion beginnen wir mit der Erstellung unserer HSV-Farbe, wobei der Farbton unsere x-Position ist und wir die Sättigung und die Helligkeit vorerst auf 1,0 belassen. Dann holen wir uns das Alpha aus der Textur, so dass es nur unser <span class="notranslate">sprite</span> Zeichen färbt und nicht das gesamte <span class="notranslate">sprite</span> Rechteck (wie wir es im Farbüberlagerungsbeispiel oben getan haben). Schließlich setzen wir unsere Fragmentfarbe auf unsere HSV-Farbe, die mit dem Alpha in RGB umgewandelt und mit der Scheitelfarbe multipliziert wird (es ist eine gute Praxis, dies immer zu tun).</p>
    <p class="dropspot">Was unsere Auslosung <span class="notranslate">code</span> betrifft, so ist sie im Moment unbedeutend:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Schauen wir uns an, was wir haben:</p>
    <p class="dropspot"><img>Wir sind nahe an dem, was wir wollen, aber es gibt ein Problem: Wir sehen nicht alle Farben auf einmal in jedem Frame der Animation, und die Farben scheinen sich zufällig zu ändern. Der Grund dafür ist, dass wir davon ausgingen, dass <span class="inline">v_vTexcoord</span> uns die Koordinaten des <span class="notranslate">sprite</span> gibt, beginnend in der linken oberen Ecke (0,0) und endend in der rechten unteren Ecke (1,1), was in Shadern Standard ist. Aus Optimierungsgründen packt <span class="notranslate">GameMaker</span> jedoch so viele Texturen wie möglich in eine so genannte <a href="../Settings/Texture_Information/Texture_Pages.htm">Texturseite</a> zusammen <a href="../Settings/Texture_Information/Texture_Pages.htm">,</a> und deshalb sieht unsere Textur tatsächlich so aus:</p>
    <p class="dropspot"><img>Wie oben erklärt, gibt uns <span class="inline">v_vTexcoord</span> die absoluten Koordinaten der <span class="notranslate">sprite</span> innerhalb dieser gesamten Texturseite, aber was wir wollen, ist ein Wert von 0,0 bis 1,0, der nur unsere aktuelle <span class="notranslate">sprite</span> abdeckt. Dieser Vorgang wird als <strong>Normalisierung</strong> bezeichnet (einen Wert erhalten und ihn in einen Bereich von 0 bis 1 übersetzen). Um unsere horizontalen Werte zu normalisieren, müssen wir die Werte von x0 und x1 im obigen Bild kennen. Glücklicherweise verfügt <span class="notranslate">GameMaker</span> über eine Funktion, die uns die Position jeder Ecke in unserem <span class="notranslate">sprite</span> innerhalb der Texturseite angibt. Zuerst müssen wir zum Ereignis "Erstellen" gehen und eine Uniform erstellen, um diese Daten an den Shader weiterzugeben:</p>
    <p class="code">// Create Event<br />
      _uniUV = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);</p>
    <p class="dropspot">Und wir modifizieren das Draw-Ereignis, um die Werte zu erhalten und sie dann an den Shader zu übergeben:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Die Funktion <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a> nimmt ein <span class="notranslate">sprite</span> und einen Index und gibt ein Array mit einer Vielzahl von Informationen zurück, z. B. die Koordinaten für jede Ecke, wie viele Pixel zur Optimierung beschnitten wurden, usw. Wir interessieren uns für zwei dieser Werte: die linken und rechten Koordinaten des <span class="notranslate">sprite</span>, die in <span class="inline">uv[0]</span> bzw. <span class="inline">uv[2]</span> gespeichert sind. Im Fragment-Shader werden wir diese Werte nun verwenden, um die normalisierte horizontale Position wie folgt zu berechnen:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec3 col = vec3(pos, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Hier fügen wir die einheitliche Variable am Anfang der Datei mit demselben Namen ein, den wir im Ereignis "Create" verwendet haben. Als Nächstes berechnen wir die normalisierte horizontale Position, indem wir unsere aktuelle <span class="inline">x</span> -Koordinate in den Ursprung verschieben ( <span class="inline">v_vTexcoord.x - u_uv[0]</span>) und sie dann durch die Breite von <span class="notranslate">sprite</span> teilen, um den Bereich von 0 bis 1 zu erhalten (<span class="inline">u_uv[1] - u_uv[0]</span>).</p>
    <p class="dropspot">Das Ergebnis ist:</p>
    <p class="dropspot"><img>Das war's! Das ist genau das, was wir wollten. Wir können jede Farbe des Spektrums in unserem <span class="notranslate">sprite</span> sehen.</p>
    <p class="dropspot">Damit sind Sie vielleicht zufrieden, aber wir können noch mehr Spaß mit diesem Shader haben. Wie wäre es, wenn wir einen Offset zu den Farben hinzufügen, der auf der Zeit basiert, um Bewegung zu erzeugen? Dazu benötigen wir zwei zusätzliche Variablen für <strong>Geschwindigkeit </strong>und <strong>Zeit</strong>. Außerdem benötigen wir zwei weitere Uniformen, eine für jede der neuen Variablen, so dass das Ereignis "Erstellen" zu einem Ereignis wird:</p>
    <p class="code">// Create Event<br />
      _uniUV    = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br />
      _uniTime  = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br />
      _uniSpeed = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br />
      _time  = 0;<br />
      _speed = 1.0;</p>
    <p class="dropspot">Wir müssen auch die Zeit für jeden Frame erhöhen, also fügen wir im Step Event hinzu:</p>
    <p class="code">// Step Event<br />
      _time += 1 / room_speed;</p>
    <p class="dropspot">Gehen wir nun zum Draw-Event, um diese Uniformen an den Shader zu senden:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      shader_set_uniform_f(_uniSpeed, _speed);<br />
      shader_set_uniform_f(_uniTime, _time);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Schließlich kehren wir zu unserem Shader zurück, um diese Variablen tatsächlich zu verwenden. Wir multiplizieren die Geschwindigkeit mit der Zeit und addieren sie zur Position, etwa so:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      uniform float u_speed;<br />
      uniform float u_time;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec3 col = vec3((u_time * u_speed) + pos, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Wenn Sie alles richtig gemacht haben, sollten Sie etwa so etwas sehen:</p>
    <p class="dropspot"><img>Um diesen Shader fertigzustellen, fügen wir ein paar weitere Uniformen hinzu, um ihn noch weiter anzupassen. Die ersten beiden dienen der Steuerung von Sättigung und Helligkeit. Die nächste nennen wir &quot;Abschnitt&quot; und ihre Funktion ist es, dem Benutzer zu ermöglichen, eine Zahl zwischen Null und Eins zu übergeben, um zu bestimmen, welchen Prozentsatz des gesamten Spektrums wir zu einer Zeit sehen. Zuletzt fügen wir eine Variable namens &quot;mix&quot; hinzu, die angibt, wie stark wir unsere Shader-Farbe mit der Original-Texturfarbe mischen wollen (1.0 ist ganz Regenbogen, 0.0 ist ganz Textur). Wie immer beginnen wir mit dem Hinzufügen der Variablen zum Ereignis "Create":</p>
    <p class="code">// Create Event<br />
      _uniUV         = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br />
      _uniTime       = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br />
      _uniSpeed      = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br />
      _uniSection    = shader_get_uniform(shdrRainbow, &quot;u_section&quot;);<br />
      _uniSaturation = shader_get_uniform(shdrRainbow, &quot;u_saturation&quot;); <br />
      _uniBrightness = shader_get_uniform(shdrRainbow, &quot;u_brightness&quot;);<br />
      _uniMix        = shader_get_uniform(shdrRainbow, &quot;u_mix&quot;);<br />
      <br />
      _time  = 0;<br />
      _speed = 1.0;<br />
      _section = 0.5;<br />
      _saturation = 0.7;<br />
      _brightness = 0.8;<br />
      _mix = 0.5;
    </p>
    <p class="dropspot">Unser Auslosungsereignis ändert sich, um diese Uniformen wie folgt einzubeziehen:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      shader_set_uniform_f(_uniSpeed, _speed);<br />
      shader_set_uniform_f(_uniTime, _time);<br />
      shader_set_uniform_f(_uniSaturation, _saturation);<br />
      shader_set_uniform_f(_uniBrightness, _brightness);<br />
      shader_set_uniform_f(_uniSection, _section);<br />
      shader_set_uniform_f(_uniMix, _mix);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Was den Shader betrifft, müssen wir die Sättigung und Helligkeit an die Farbe weitergeben, was sich auf die von unserer Hilfsfunktion erzeugte Farbe auswirken wird. Der Abschnitt muss mit unserer Position multipliziert werden, um den Bereich zu reduzieren. Wir werden auch die gesamte Texturfarbe erfassen, damit wir unsere endgültige Farbe berechnen können, indem wir die Texturfarbe mit der RGB-Konvertierung unserer Farbe mischen. Der letzte Parameter der Mischfunktion bestimmt, wie viel von der zweiten Farbe wir hinzufügen wollen. Dies ist unser endgültiger Shader-Code:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      uniform float u_speed;<br />
      uniform float u_time;<br />
      uniform float u_saturation;<br />
      uniform float u_brightness;<br />
      uniform float u_section;<br />
      Uniform float u_mix;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          <br />
          vec3 col = vec3(u_section * ((u_time * u_speed) + pos), u_saturation, u_brightness);<br />
        vec4 finalCol = mix(texColor, vec4(hsv2rgb(col), texColor.a), u_mix);<br />
          <br />
          gl_FragColor = v_vColour * finalCol;<br />
      }
    </p>
    <p class="dropspot">Und unser Endergebnis ist dieses!</p>
    <p class="dropspot"><img alt="Shader Fragments" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Fragments.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Das ist das Ende dieses kurzen Leitfadens, und Sie sollten nun ein besseres Verständnis dafür haben, wie Shader funktionieren und wofür sie eingesetzt werden können. Sie sollten sich die Zeit nehmen, mit den Shadern zu spielen, die Sie nach dieser Anleitung erstellt haben, und versuchen, mit ihnen zu experimentieren, um andere Dinge zu tun - wie wäre es mit der Erstellung eines Weichzeichner-Shaders oder eines Shaders, der einen monochromen Bildschirm im Gameboy-Stil erzeugt? - denn Shader sind ein unglaublich mächtiges Werkzeug, um Ihren Spielen visuelle Komplexität und Stil zu verleihen.</p>
  <p class="note">Wir bedanken uns bei <a href="https://twitter.com/AleHitti">Alejandro Hitti</a> und <strong>Amazon</strong> für die Erlaubnis, diesen Leitfaden zu vervielfältigen. Die Originalversion finden Sie auf dem <a href="https://developer.amazon.com/es/blogs/appstore/post/acefafad-29ba-4f31-8dae-00805fda3f58/intro-to-shaders-and-surfaces-with-gamemaker-studio-2">Amazon Developer Blog</a>.</p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Zurück: <a href="Additional_Information.htm">Zusätzliche Informationen</a></div>
        <div style="float:right">Nächste: <a href="Guide_To_Primitives_And_Vertex_Building.htm">Leitfaden für Primitive und Vertexaufbau</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Alle Rechte vorbehalten</span></h5>
  </div>
  <!-- KEYWORDS
Shaders
Using Shaders
Shader Guide
Guide To Using Shaders
-->
  <!-- TAGS
using_shaders
-->
</body>
</html>