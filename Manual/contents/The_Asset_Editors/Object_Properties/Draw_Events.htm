<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Ereignisse auslosen</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing the draw event." />
  <meta name="rh-index-keywords" content="Objects - Draw Events" />
  <meta name="search-keywords" content="draw event,draw begin,draw end,pre-draw,post draw,draw GUI,draw order" />
  <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
  <script src="../../assets/scripts/main_script.js"></script>
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Die Auslosungsereignisse</h1>
  <p><img>Die Ereigniskategorie "Zeichnen" enthält alle Ereignisse, die bestimmen, was Sie auf dem Bildschirm sehen, wenn Sie Ihr Spiel ausführen. Sie ist aufgeteilt in verschiedene
    Die folgende Abbildung zeigt die Reihenfolge, in der die einzelnen Ereignisse ausgeführt werden:</p>
  <p><img>Das normale Draw-Ereignis unterteilt sich in drei Untertypen: Das <strong>Draw Begin</strong>, das Standard <strong>Draw</strong> und das
   <strong>Draw End-Ereignis</strong>. Im Allgemeinen wirst du nur das Standard Draw-Ereignis verwenden müssen, und du solltest dir bewusst sein, dass alle Instanzen in einem Raum dieses Ereignis bei jedem Schritt des Spiels auslösen, so dass dieses Ereignis immer aufgerufen wird, solange
    solange die Instanz das <strong>Sichtbar-Flag </strong>auf true gesetzt hat. Es ist wichtig zu verstehen, dass selbst wenn du nichts für dieses Sub-Ereignis in den Objekteigenschaften definiert hast (d.h.: keine <span class="notranslate">code</span> oder Aktionen), <em>wenn dem Objekt eine <span class="notranslate">sprite</span> zugewiesen ist, es trotzdem ein Draw-Ereignis hat, das ausgelöst wird</em>.
    Das liegt daran, dass <span data-keyref="GameMaker Name">GameMaker</span> zwei Möglichkeiten hat, Dinge im Draw-Ereignis zu zeichnen:</p>
  <ul class="colour">
    <li>die <strong>Standard-Zeichnung</strong>, d. h., wenn Sie <span class="notranslate">sprite</span> in den Objekteigenschaften definieren und keine Aktionen oder <span class="notranslate">code</span> im normalen Draw-Ereignis platzieren. In diesem Fall zeichnet <span data-keyref="GameMaker Name">GameMaker</span> die zugewiesene <span class="notranslate">sprite</span> automatisch. Beachten Sie, dass alle Transformationen
      die du in anderen Ereignissen durchführst, um den Bildmaßstab, den Index, die Überblendung usw. zu ändern, ebenfalls berücksichtigt werden, solange das Draw-Ereignis leer ist.</li>
    <li>die <strong>benutzerdefinierte Zeichnung</strong>, bei der Sie <span class="notranslate">code</span> oder Aktionen in das Zeichnungsereignis setzen. Damit sagst du <span data-keyref="GameMaker Name">GameMaker</span>: &quot; <em>Ich möchte kontrollieren, was du für Instanzen dieses Objekts zeichnest</em>&quot;, und es überschreibt die Standard
      Zeichnung. Das bedeutet, dass du zum Beispiel ein Objekt mit einer <span class="notranslate">sprite</span> zuweisen kannst, dann das Draw-Ereignis auf Text zeichnen setzt und der Text auf dem Bildschirm gezeichnet wird, aber die <span class="notranslate">sprite</span> wird <em>nicht </em>gezeichnet, da du <span data-keyref="GameMaker Name">GameMaker</span> nicht gesagt hast, sie zusammen mit dem Text zu zeichnen.
      es zusammen mit dem Text zu zeichnen.</li>
  </ul>
  <p>Die übrigen Auslosungsereignisse werden in den nachstehenden Abschnitten erläutert:</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Zeichenbeginn und Zeichenende</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Neben dem Hauptereignis "Ziehen" gibt es noch die Ereignisse " <strong> Ziehbeginn"</strong> und " <strong>Ziehende"</strong>. Diese verhalten sich genauso wie ein normales Draw-Ereignis (d.h. sie zeichnen, was auch immer man in sie einträgt, in jedem Schritt des Spiels und für
      alle Ansichtsfenster), aber sie zeichnen nichts, wenn sie nicht explizit zu einem Objekt hinzugefügt wurden, und sie werden immer vor/nach dem Standard-Draw-Ereignis ausgeführt. Wenn das Spiel also läuft, hast du <em>immer</em> das
      Draw Begin Event für alle Instanzen, dann das Draw Event für alle Instanzen und schließlich das Draw End Event für alle Instanzen.</p>
    <p class="dropspot">Auf diese Weise können Sie Dinge zeichnen oder Zeicheneigenschaften im Schritt Draw Begin in einer Instanz festlegen und sicher sein, dass alle Instanzen mit einem Standard Draw Event oder Draw End Event diese Eigenschaften verwenden oder über das zeichnen, was die erste Instanz gezeichnet hat. Im Grunde genommen
      ist es ein sicherer Weg, um zu garantieren, dass bestimmte Dinge zu bestimmten Zeiten gezeichnet werden, ähnlich wie es die Ereignisse <strong>Begin Step</strong> und <strong>End Step </strong>tun.</p>
    <p class="dropspot">Beim Zeichnen von Dingen in <span data-keyref="GameMaker Name">GameMaker</span> sind einige Dinge zu beachten, egal ob es sich um einen <span class="notranslate">sprite</span>, einen Shader oder einen 3D-Buffer handelt:</p>
    <ul class="colour">
      <li class="dropspot">Das Draw-Ereignis ist ein sehr intensives Ereignis, da es eines der Ereignisse ist, das die meiste Zeit und die meisten Ressourcen in Anspruch nimmt... aus diesem Grund ist es nie eine gute Idee, im Draw-Ereignis etwas anderes zu tun als zu zeichnen. Sparen Sie sich also Ihre großen <span class="notranslate">code</span> oder komplexen Aktionen
        für das Step-Ereignis oder Alarme oder jedes andere passende Ereignis auf, aber lassen Sie das Draw-Ereignis für das Zeichnen frei, denn das ist es, was es am besten kann.</li>
      <li class="dropspot">Wenn für Ihr Objekt der Parameter visible auf <em>off </em> gesetzt wurde (so dass die Instanzen des Objekts nicht gezeichnet werden), <strong>werden alle Draw-Ereignisse übersprungen </strong>(mit Ausnahme des <strong>Resize-Ereignisses </strong>). Das bedeutet, dass das Unsichtbarmachen einer Instanz
        unsichtbar zu machen, stoppt die Ausführung aller <span class="notranslate">code</span>, die in einem dieser Ereignisse platziert sind, also setze keine wesentlichen <span class="notranslate">code</span> in die Zeichenereignisse, wenn sie nicht sichtbar sein sollen.</li>
      <li class="dropspot">Was Sie zeichnen, hat nichts mit der gewählten Kollisions-Engine (traditionell oder Physik) zu tun, da diese durch die Objekteigenschaften und die <span class="notranslate">sprite</span> (oder Maske), die dem Objekt zugewiesen wurde, definiert ist.</li>
    </ul>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">GUI zeichnen</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Der Ereignistyp Draw GUI fällt unter die Kategorie Draw Event und ist speziell für das Zeichnen von <a class="glossterm" data-glossterm="GUI" href="#">GUI-Elementen</a> gedacht, die nicht von der Skalierung oder Drehung der Ansichtskamera betroffen sind. Das bedeutet, dass Sie
      eine Instanz alle Elemente für Ihr <a class="glossterm" data-glossterm="HUD" href="#">HUD</a> oder Ihre Benutzeroberfläche zeichnen lassen können, ohne dass die Positionierung der Elemente auf der Position der Instanz im Raum oder der Position der aktuellen Kameraansicht basieren muss.
      der aktuellen Kameraansicht abhängen.</p>
    <p class="dropspot">Beim Zeichnen in diesen Ereignissen ist es wichtig, dass Sie verstehen, dass sich die Zeichenkoordinaten nicht ändern, selbst wenn Kameraansichten aktiv sind und (0,0) <em>immer </em>die linke obere Ecke der Anwendungsoberfläche oder der Anzeige ist (siehe den
      Hinweis am Ende dieses Abschnitts), und die Standardbreite und -höhe sind 1:1 mit der Anwendungsoberfläche. Die Tiefenordnung wird auch zwischen verschiedenen Instanzen auf verschiedenen Ebenen beibehalten (eine Instanz auf einer höheren Ebene wird also unter
      (eine Instanz auf einer höheren Ebene wird also unter einer Instanz auf einer niedrigeren Ebene gezeichnet) und auch innerhalb der Ereignisse selbst, da das Ereignis <strong>Draw GUI Begin</strong> zuerst für alle Instanzen zeichnet, dann wird das Standard-Ereignis <strong>Draw GUI</strong> für alle darüber liegenden Instanzen gezeichnet und schließlich wird das Ereignis <strong>Draw Gui End </strong>
      ausgelöst wird.</p>
    <p class="dropspot">Auf diese Weise können Sie Dinge zeichnen oder Zeicheneigenschaften im Draw GUI Begin in einer Instanz setzen und sicher sein, dass alle Instanzen mit einem Standard Draw GUI oder Draw GUI End Ereignis diese Eigenschaften verwenden oder überzeichnen, was die erste Instanz gezeichnet hat. Im Grunde genommen
      ist dies ein sicherer Weg, um zu garantieren, dass bestimmte Dinge zu bestimmten Zeiten gezeichnet werden, ähnlich wie es die Ereignisse <strong>Begin Step</strong> und <strong>End Step</strong> tun.</p>
    <p class="dropspot">Diese Ereignisse können auch in Verbindung mit den normalen Draw-Ereignissen verwendet werden (die wie üblich von der Position, Skalierung und Drehung der Kameraansicht beeinflusst werden). Wenn Sie kein Draw-Ereignis haben, aber ein Draw-GUI-Ereignis, dann wird <span data-keyref="GameMaker Name">GameMaker</span> trotzdem
      standardmäßig die <span class="notranslate">sprite</span> für die Instanz (wenn sie eine hat) wie gewohnt zeichnen.</p>
    <p class="dropspot">In Bezug auf die anderen Draw-Ereignisse werden die Draw-GUI-Ereignisse immer über alles gezeichnet, was in den normalen Draw-Ereignissen gezeichnet wird. Wenn Sie also eine Instanz auf einer niedrigeren Ebene mit einem Draw GUI-Ereignis haben, wird sie über der Instanz gezeichnet, die sich auf einer höheren Ebene
      mit einem normalen Draw-Ereignis. Wenn beide Instanzen ein Draw GUI-Ereignis haben, dann wird die Reihenfolge der Ebenen beachtet.</p>
    <p class="note"><strong>HINWEIS</strong>: Dieses Ereignis zeichnet standardmäßig 1:1 mit der Größe der Anwendungsoberfläche, die normalerweise die Größe des Raums oder des View Ports ist. Das bedeutet, dass, wenn du <strong>Aspect Ratio Correction</strong> in den Game Options
      aktiviert haben, wird die grafische Benutzeroberfläche nicht über die schwarzen Balken gezeichnet, die das Spiel &quot;letterboxen&quot;. Dieses Verhalten kann mit der Funktion <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_maximise.htm"><span style="font-size:14px;"> <span class="inline" style="font-size: 14px">display_set_gui_maximise()</span></span></a> Funktion ausgeschaltet werden,
      und Sie können das GUI-Ereignis auch auf eine bestimmte Größe festlegen, die dann automatisch an die Abmessungen des Bildschirms oder der Anwendungsoberfläche angepasst wird, indem Sie die Funktion <a href="../../GameMaker_Language/GML_Reference/Cameras_And_Display/display_set_gui_size.htm"><span class="inline" style="font-size: 14px">display_set_gui_size()</span></a>.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Vor und nach der Auslosung</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Die Ereignisse Pre Draw und Post Draw gehören zur Kategorie Draw Event. Im Gegensatz zu den anderen Draw-Ereignissen zeichnen diese jedoch <em>direkt </em>in den <a class="glossterm" data-glossterm="Display-Puffer" href="#">Anzeigepuffer</a>, der die Größe
      des kombinierten Bildschirmbereichs für alle derzeit sichtbaren Ansichtsfenster <em>bzw. </em>die Fenstergröße, wenn nur ein Ansichtsfenster oder gar keins verwendet wird. Das folgende Bild veranschaulicht dies:</p>
    <p class="dropspot"><img>Wenn Sie also die Pre- oder Post-Draw-Ereignisse verwenden, zeichnen Sie auf das Vollbild-Rendering-Ziel (display <span class="notranslate">buffer</span>), das die gleiche Größe wie das Fenster hat, in das alle Viewports passen.
      die gleiche Größe wie das Fenster hat, in das alle Ansichtsfenster eingepasst werden. Wenn Sie keine Ansichtsfenster aktiviert haben, wird stattdessen die Größe des Fensters selbst verwendet.</p>
    <p class="dropspot">Das Pre-Draw-Ereignis wird vor jedem anderen Draw-Ereignis ausgelöst, und in ihm können Sie Werte setzen, Draw-Eigenschaften einstellen und sogar Dinge zeichnen, ohne sich um die Viewports oder die Größe der GUI-Ebene zu kümmern (die Größe der GUI-Ebene kann dieselbe sein wie die des Bildschirms
     <span class="notranslate">buffer</span> sein, aber nicht unbedingt, da Sie die GUI-Auflösung in <span class="notranslate">code</span> einstellen können).</p>
    <p class="dropspot">Es ist erwähnenswert, dass dieses Ereignis eintritt <em>, bevor </em>die Anzeige <span class="notranslate">buffer</span> für das reguläre Zeichnen freigegeben wird, was bedeutet, dass, wenn Sie nicht <span class="notranslate">switch</span> die Ansichtsfreigabe im Raum-Editor deaktivieren, nichts von dem, was im Pre Draw-Ereignis gezeichnet wird, zu sehen sein wird, da das
      das erste Zeichnen des Ansichtsfensters wird es löschen. Wenn Sie in der Lage sein wollen, durch die Ansichtsfenster selbst zu sehen, oder wenn Sie überhaupt keine Ansichtsfenster verwenden, dann sollten Sie auch die Hintergrundfarbe so einstellen, dass sie einen Alpha-Wert von 0 hat in der <strong><a href="../Rooms.htm">Raum-Editor</a></strong>.</p>
    <p class="note"><strong>HINWEIS</strong>: Wenn Sie <span class="notranslate">switch</span> diese Optionen deaktivieren, können Sie unerwünschte Artefakte auf dem Bildschirm sehen, wenn das Spiel getestet wird (wie &quot;Spuren&quot; von Instanzen). Das liegt daran, dass Sie direkt über den vorherigen Frame
      der Anzeige <span class="notranslate">buffer</span> zeichnen, ohne dass diese gelöscht wird. Sie können jedoch mit <span class="inline" style="font-size: 14px"><a href="../../GameMaker_Language/GML_Reference/Drawing/Colour_And_Alpha/draw_clear_alpha.htm">draw_clear_alpha()</a> </span>verwenden, um dies
      selbst machen.</p>
    <p class="dropspot">Das Post Draw-Ereignis wird <em>nach </em>allen Standard-Zeichenereignissen, aber <em>vor </em>den Draw-GUI-Ereignissen ausgelöst. Wie das Pre Draw-Ereignis basiert es auf der Größe der Anzeige <span class="notranslate">buffer</span> und ist vor den Draw GUI-Ereignissen platziert, um Ihnen zu ermöglichen
      Nachbearbeitungseffekte und andere Dinge auf einer Vollbildschirmbasis einfach und leicht durchführen zu können, ohne dabei irgendwelche <a class="glossterm" data-glossterm="GUI" href="#">HUD/GUI-Elemente</a> 
      die Sie möglicherweise in Ihrem Spiel haben.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#">Fenstergröße ändern</a></p>
  <div class="droptext" data-targetname="drop-down3">
    <p class="dropspot">Dieser Ereignistyp fällt unter die Kategorie "Draw Event" (Zeichnen-Ereignis), und obwohl er eigentlich nichts zeichnet, reagiert er auf Änderungen in der Anzeige <span class="notranslate">buffer</span> - insbesondere ist er dafür gedacht, auf die Änderung der Größe der UWP-Anzeige <span class="notranslate">buffer</span> zu reagieren, wenn das
      Spielfenster &quot;gefangen&quot; wird.</p>
    <p class="dropspot">Auf dem UWP-Ziel <span class="notranslate">platform</span> ist es wichtig, dass Sie jede Größenänderung der Anzeige <span class="notranslate">buffer</span> durch das &quot;Einrasten&quot; des Spielfensters abfangen (wenn der Benutzer das Fenster z. B. an die Seite des Bildschirms zieht). Dieses Ereignis wird genau das tun und
      wird jedes Mal ausgelöst, wenn das Fenster verändert wird, so dass Sie hier benutzerdefinierte <span class="notranslate">code</span> hinzufügen können, die die Größe der Ansicht ändern oder <a class="glossterm" data-glossterm="HUD" href="#">HUD-Elemente</a> nach Bedarf neu positionieren. Diese Funktion wird als eine bequeme
      Weg, um das Ereignis <span class="notranslate">code</span> zu vermeiden, das diese Dinge ständig überprüft.</p>
    <p class="note"><strong>HINWEIS</strong>: Sie können in diesem Ereignis nicht zeichnen! Es wird durch die Größenänderung des Fensters ausgelöst und ist nur dazu da, diese Änderung abzufangen... jede Zeichnung, die noch gemacht werden soll, muss in einem der anderen Zeichnungsereignisse erfolgen.</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Zurück: <a href="Object_Events.htm">Objekt Ereignisse</a></div>
        <div style="float:right">Nächste: <a href="Async_Events.htm">Asynchrone Ereignisse</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Alle Rechte vorbehalten</span></h5>
  </div>
  <!-- KEYWORDS
Draw Events
Pre Draw Event
Post Draw Event
Draw Begin Event
Draw End Events
Draw GUI Events
Draw GUI Begin Event
Draw GUI End Event
Pre Draw Event
Post Draw Event
Window Resize Event
-->
  <!-- TAGS
draw_events
-->

</body></html>