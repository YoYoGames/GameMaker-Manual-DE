<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Bewegung und Kontrollen</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code and GML Visualto show people how to move things around within a game." />
  <meta name="rh-index-keywords" content="Quick Start - Movement And Controls" />
  <meta name="search-keywords" content="movement,controls" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Bewegung und Kontrollen</h1>
  <p>Im <a href="Drawing.htm">vorangegangenen Abschnitt</a> dieser Kurzanleitung wurden einige Beispiele für das Zeichnen von Objekten auf dem Bildschirm gegeben, aber das Zeichnen von Objekten bringt nicht viel, wenn man sie nicht auch bewegen kann... In diesem Abschnitt geben wir Ihnen also einige Beispiele für die Bewegung Ihrer Objekte sowie einige grundlegende Steuerungsschemata für verschiedene Arten von Spielen. Alle Beispiele werden sowohl mit <span class="notranslate">GML</span> Visual als auch mit <span class="notranslate">GML</span> <span class="notranslate">Code</span> gegeben, Sie können also das verwenden, womit Sie sich wohler fühlen. Bitte beachten Sie, dass wir hier nicht zu tief in die Materie eindringen werden, da wir möchten, dass Sie so schnell wie möglich mit dem Erstellen von Objekten beginnen können. Wir möchten Sie daher ermutigen, alle Links zu erkunden und die Suchfunktion des Handbuchs zu nutzen, um nach zusätzlichen Informationen zu suchen, wenn Sie sich nicht sicher sind.</p>
  <p>Bevor Sie weitermachen, sollten Sie auf der <a href="../Introduction/The_Start_Page.htm">Startseite</a> ein neues Projekt erstellen (entweder <span class="notranslate">GML</span> oder <span class="notranslate">GML</span> Visual) und ein paar <span class="notranslate">sprites</span> sowie ein oder zwei Objekte hinzufügen (oder erstellen) - denn wir werden Ihnen einige <span class="notranslate">code</span> geben, die Sie mit diesen testen können - und sicherstellen, dass das Projekt einen Raum hat, in dem Sie Instanzen platzieren können. Machen Sie sich nicht zu viele Gedanken darüber, wie die von Ihnen erstellten <span class="notranslate">sprites</span> aussehen, ein einfaches weißes Quadrat reicht aus, und sobald Sie alles vorbereitet haben, können Sie mit den unten aufgeführten Beispielen beginnen.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Auf die Maus zugehen</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot">Eine der einfachsten Möglichkeiten, ein Objekt in Bewegung zu setzen und mit dem Spieler zu interagieren, ist die Verwendung der Maus. In diesem Beispiel zeigen wir Ihnen, wie Sie mit einigen grundlegenden <span class="notranslate">code</span> ein Objekt dazu bringen, sich dorthin zu bewegen, wo der Benutzer die linke Maustaste geklickt hat <img>.</p>
    <p class="dropspot">Öffnen Sie zunächst ein Objekt, weisen Sie ihm ein <span class="notranslate">sprite</span> zu und geben Sie ihm ein <strong>globales Linke-Maus-unten-Ereignis</strong>:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="dropspot">Wir verwenden die <strong>globalen </strong>Mausereignisse, weil sie einen Klick überall im Raum erkennen, während die normalen Mausereignisse nur dann einen Klick erkennen, wenn die Maus tatsächlich innerhalb des <a class="glossterm" data-glossterm="Begrenzungsrechteck" href="#">Begrenzungsrahmens der</a> Instanz klickt. In diesem Ereignis wollen wir diese Aktionen oder diesen Code hinzufügen:</p>
    <p class="dropspot"><img alt="Adding The Mouse Left Button Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_GlobalLMBDownEvent.png" /></p>
    <p class="code">move_towards_point(mouse_x, mouse_y, 2);</p>
    <p class="dropspot">Hier weisen wir die Instanz an, sich zu einer Position auf dem Bildschirm zu bewegen, in diesem Fall zu den Positionen &quot;<span class="inline">mouse_x</span>&quot; und &quot;<span class="inline">mouse_y</span>&quot; (&quot;<span class="inline">mouse_x</span>&quot; und &quot;<span class="inline">mouse_y</span>&quot; sind <strong>eingebaute </strong><span class="glossextra">Variablen</span>, die immer die aktuelle Position des Mauszeigers enthalten). Bei <span class="notranslate">GML</span> Visual wird dies durch Setzen der Variablen &quot;<span class="inline">direction</span>&quot; und &quot; <span class="inline">speed</span>&quot; erreicht. <a href="../GameMaker_Language/GML_Reference/Asset_Management/Instances/Instance_Variables/Instance_Variables.htm"><strong>Instanz-Variablen</strong></a>setzt, während <span class="notranslate">GML</span> dies mit der Funktion <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Movement/move_towards_point.htm"><span class="inline">move_towards_point()</span></a> (diese setzt auch die Variablen <span class="inline">speed </span>und <span class="inline">direction </span>, nur in einer einzigen, einfach zu verwendenden Funktion).</p>
    <p class="dropspot">Platziere eine Instanz dieses Objekts in einem Raum und drücke dann die Play-Taste <img>. Klicke dann auf <img> um den Raum herum, damit sich die Instanz in Richtung der Maus bewegt:</p>
    <p class="dropspot"><img>Großartig! Die Instanz des Objekts bewegt sich jetzt dorthin, wo du geklickt hast, und wenn du die Taste gedrückt hältst, folgt die Instanz einfach dem Mauszeiger weiter. Allerdings gibt es ein Problem... Nachdem du einmal geklickt und losgelassen hast, bewegt sich die Instanz weiter und verlässt schließlich den Raum! Es gibt mehrere Möglichkeiten, dies zu beheben, und welche du wählst, hängt davon ab, was du tun willst, aber die einfachste Lösung für jetzt ist es, einfach ein <strong>Globales Maustastenfreigabe-Ereignis</strong> hinzuzufügen, also füge das jetzt dem Objekt hinzu und gib ihm diesen Code:</p>
    <p class="dropspot"><img alt="GML VisualTo Move Instance Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_1.png" /></p>
    <p class="code">speed = 0;</p>
    <p class="dropspot">Damit folgt die Instanz dem Mauszeiger nur so lange, wie Sie die Maustaste gedrückt halten, und wenn Sie die Taste loslassen, hört sie auf, sich zu bewegen. Drücken Sie Play <img> und testen Sie es jetzt.</p>
    <p class="dropspot">Bevor wir dieses Beispiel verlassen, gibt es noch ein letztes Problem, das wir lösen müssen... Wenn Sie klicken und die Maustaste <em>gedrückt halten </em>, aber den Cursor nicht bewegen, dann bewegt sich die Instanz auf den Cursor zu und &quot;vibriert&quot; dann um ihn herum. Das liegt daran, dass sich die Instanz schneller als 1 Pixel auf einmal bewegt und so die Position &quot;überschießt&quot; und dann versucht, sich zurückzubewegen, und dann wieder überschießt, usw... (machen Sie die Bewegungsgeschwindigkeit 5 oder so ähnlich, um das Problem zu sehen, wenn es nicht sofort offensichtlich ist).</p>
    <p class="dropspot"><img>Um dieses Problem zu lösen, müssen wir dem Objekt mit diesem Code ein <strong>Step Event</strong> hinzufügen:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _dist = point_distance(x, y, mouse_x, mouse_y);<br />
      <br />
      if (_dist &lt;= speed)<br />
      {<br />
          speed = 0;<br />
      }
    </p>
    <p class="dropspot">Hier überprüfen wir einfach den Abstand zwischen der Instanz und der Mausposition, und wenn dieser gleich oder kleiner als die aktuelle Geschwindigkeit ist, setzen wir die Geschwindigkeit auf 0. Dadurch wird die Instanz angehalten, wenn sie nahe genug an der Mausposition ist, und wir bekommen nicht dieses unangenehme &quot;vibrierende&quot; Problem.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">4-Wege- und 8-Wege-Bewegung mit der Tastatur</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot"><a href="What_Is_Programming_.htm">Gleich zu Beginn dieser Anleitung</a> haben wir dir die folgende Aktion und <span class="notranslate">code</span> gezeigt, um eine Instanz in jedem Spielschritt um zwei Pixel nach rechts zu verschieben:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="code">x = x + 2;</p>
    <p class="dropspot">Diese Art der Bewegung wird als <strong>Positionsbewegung </strong>bezeichnet, da wir im Wesentlichen die Instanz aufnehmen und sie jedes Mal, wenn <span class="notranslate">code</span> ausgeführt wird, an einer neuen Position wieder ablegen. In diesem Beispiel werden wir Ihnen zeigen, wie Sie diese Art der Bewegung nutzen können, um eine Instanz in 4 Richtungen zu bewegen: nach oben, unten, links und rechts.</p>
    <p class="dropspot">Öffnen Sie zunächst ein Objekt und weisen Sie ihm ein <span class="notranslate">sprite</span> zu. Nun könnten wir an dieser Stelle verschiedene <strong>Tastaturereignisse</strong> hinzufügen und die Instanz jeweils in die gewünschte Richtung bewegen lassen. Wir möchten jedoch, dass sich der Spieler jeweils nur in eine Richtung bewegen kann, und dies nur mit den Tastaturereignissen zu tun, ist etwas komplizierter, als es mit <span class="notranslate">code</span> zu tun. Stattdessen werden wir das <strong>Schritt-Ereignis</strong> - das du jetzt zu dem Objekt hinzufügen solltest - mit den folgenden Aktionen oder <span class="notranslate">code</span> verwenden, um die Pfeiltasten zum Bewegen zu benutzen:</p>
    <p class="dropspot"><img alt="Animation Of Instance Moving Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_1.gif" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      else if (keyboard_check(vk_right))<br />
      {<br />
          x = x + 2;<br />
      }<br />
      else if (keyboard_check(vk_up))<br />
      {<br />
          y = y - 2;<br />
      }<br />
      else if (keyboard_check(vk_down))<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Wir verwenden eine &quot; <span class="inline">if... else if... else if...</span>&quot;-Struktur, um sicherzustellen, dass sich die Instanz jeweils nur in eine Richtung bewegt, also nur nach oben, unten, links oder rechts, aber nicht diagonal. Platziere eine Instanz des Objekts in einem Raum und drücke die <strong>Play-Taste </strong> <img> um es jetzt zu testen! Wenn alles richtig gelaufen ist, solltest du so etwas wie das hier haben:</p>
    <p class="dropspot"><img alt="GML VisualTo Set The Instance Speed" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_2.png" /></p>
    <p class="dropspot">Wir können dieses <span class="notranslate">code</span> auch leicht ändern, um die 4-Wege-Bewegung in eine 8-Wege-Bewegung umzuwandeln... entfernen Sie einfach die &quot; <span class="inline">else</span>&quot; Befehle aus den <span class="notranslate">code</span> Blöcken, so dass alles wie folgt aussieht:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if (keyboard_check(vk_right))<br />
      {<br />
          x = x + 2;<br />
      }<br />
      if (keyboard_check(vk_up))<br />
      {<br />
          y = y - 2;<br />
      }<br />
      if (keyboard_check(vk_down))<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Wenn Sie jetzt auf die Schaltfläche " <strong>Play </strong>" <img> klicken, sieht es ungefähr so aus:</p>
    <p class="dropspot"><img alt="Animation Showing Instance Vibrating" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_2.gif" /></p>
    <p class="dropspot">Eine letzte Sache, die für Benutzer, die mit <span class="notranslate">GML</span> programmieren, erwähnenswert ist ... Wenn Sie <span class="notranslate">GML</span> Visual verwenden, können Sie die Tastaturtaste, die Sie verwenden möchten, aus einer Dropdown-Liste auswählen, aber mit <span class="notranslate">GML</span> ist das nicht so einfach. Es gibt eine Reihe von <a href="../GameMaker_Language/GML_Reference/Game_Input/Keyboard_Input/Keyboard_Input.htm">Tastaturkonstanten</a>, die Sie verwenden können - wie die Pfeiltastenkonstanten in <span class="notranslate">code</span> oben - aber es gibt <em>keine </em>Konstanten für die alphanumerischen Tasten. Diese werden etwas anders gehandhabt und erfordern die Verwendung der Funktion <a href="../GameMaker_Language/GML_Reference/Strings/ord.htm"><span class="inline">ord()</span></a>. Die folgende <span class="notranslate">code</span> zeigt Ihnen, wie dies mit WASD anstelle der Pfeiltasten funktionieren würde:</p>
    <p class="code">if keyboard_check(ord(&quot;A&quot;))<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;D&quot;)))<br />
      {<br />
          x = x + 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;W&quot;)))<br />
      {<br />
          y = y - 2;<br />
      }<br />
      if (keyboard_check(ord(&quot;S&quot;)))<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Gamepad-Bewegung</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Wir haben die Bewegung der Maus und der Tastatur behandelt, also ist es nun an der Zeit, die Bewegung des <strong>Gamepads </strong>zu behandeln. Wir werden uns nicht mit dem D-Pad beschäftigen, denn das funktioniert genauso wie die Tastatur (ändern Sie einfach die Tastaturfunktionen im obigen Beispiel in <a href="../GameMaker_Language/GML_Reference/Game_Input/GamePad_Input/gamepad_button_check.htm"><span class="inline">gamepad_button_check()</span></a> oder <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Gamepad/If_Gamepad_Button_Down.htm">Wenn Gamepad-Taste nach unten</a>), also werden wir uns in diesem Beispiel mit der Verwendung des Analogsticks für die Bewegung beschäftigen.</p>
    <p class="dropspot">Zunächst einmal müssen wir das verwendete Gamepad erkennen. Gamepads erhalten einen ID-Wert von 0 bis 11. Daher verwenden wir den Befehl &quot; <span class="inline">for</span>&quot; <span class="notranslate">loop</span>, um die ID aller angeschlossenen Gamepads zu ermitteln und diesen ID-Wert in einer Variablen zur späteren Verwendung zu speichern. Da wir nur das erste angeschlossene Gamepad erkennen wollen und nicht alle, verwenden wir den Befehl &quot; <span class="inline">break</span>&quot;, nachdem wir ein Gamepad erkannt haben, so dass er <span class="notranslate">loop</span> &quot;unterbricht&quot; (wenn z. B. das erste angeschlossene Gamepad die ID 4 hat, wird <span class="notranslate">loop</span> nur fünfmal ausgeführt, wobei die ID-Werte 0 - 4 geprüft werden und dann <span class="notranslate">loop</span> abgebrochen wird, wenn das Gamepad gefunden wird). Erstellen (oder öffnen) Sie also ein Objekt, weisen Sie ihm eine <span class="notranslate">sprite</span> zu und fügen Sie dann ein <strong>Create Event</strong> mit folgendem Inhalt hinzu:</p>
    <p class="dropspot"><img alt="GML VisualActions For The Step Event" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_3.png" /></p>
    <p class="code">gamepad_id = -1;<br />
      <br />
      for (var i = 0; i &lt; 12; i += 1;)<br />
      {<br />
          if (gamepad_is_connected(i)) <br />
          {<br />
              gamepad_id = i;<br />
              gamepad_set_axis_deadzone(gamepad_id, 0.2);<br />
      <br />
              break;<br />
          }<br />
      }
    </p>
    <p class="dropspot">Beachten Sie, dass wir in der obigen <span class="notranslate">code</span> die <strong> <a class="glossterm" data-glossterm="Totzone" href="#">Totzone</a> </strong>für das Gamepad. Der Grund dafür ist, dass die Analogsticks verschiedener Gamepads unterschiedlich empfindlich sind. Manchmal sind sie so empfindlich, dass sie unerwünschte Bewegungen in deinen Spielen verursachen können, wenn du keine Deadzone einstellst. Daher setzen wir die Totzone auf einen Wert wie 0,2, um <span data-keyref="GameMaker Name">GameMaker</span> anzuweisen, alle Gamepad-Stick-Werte unter diesem <a class="glossterm" data-glossterm="absolut" href="#">absoluten</a> Wert zu ignorieren.</p>
    <p class="dropspot">Um die eigentliche Bewegung hinzuzufügen, benötigen wir ein <strong>Step-Event</strong>. Fügen Sie dieses also jetzt hinzu und geben Sie ihm die folgende <span class="notranslate">GML</span> Visual oder GML:</p>
    <p class="dropspot"><img alt="GML VisualExample" class="center" src="../assets/Images/QS_Guide/QS_DnD_Example.png" /></p>
    <p class="code">if gamepad_id &gt; -1<br />
      {<br />
          var _h = gamepad_axis_value(gamepads[0], gp_axislh);<br />
          var _v = gamepad_axis_value(gamepads[0], gp_axislv);<br />
          x += _h * 4;<br />
          y += _v * 4;<br />
      }</p>
    <p class="dropspot">Hier wird der <em>linke </em>Knüppel auf horizontale oder vertikale Bewegung geprüft. Die Achsenfunktionen geben einen Wert zwischen -1 und 1 zurück, d.h. für die horizontale Achse ist -1 links, 0 ist keine Bewegung und 1 ist rechts, und für die vertikale Achse ist es -1 für aufwärts, 0 für keine Bewegung und 1 für abwärts. Beachten Sie auch, dass die Werte <em>zwischen </em>-1 und 1 liegen, so dass - zum Beispiel - die horizontale Achse einen Wert von 0,5 liefern könnte, was bedeutet, dass der Steuerknüppel auf halbem Weg zwischen der &quot;Ruheposition&quot; und ganz nach rechts geschoben ist. Aus diesem Grund multiplizieren wir den Wert mit 4 (du kannst mit jedem beliebigen Wert multiplizieren, abhängig von der Geschwindigkeit, mit der sich die Instanz bewegen soll) - das bedeutet, dass die Geschwindigkeit der Instanz variiert, je nachdem, wie viel Bewegung auf der Stick-Achse gemacht wurde.</p>
    <p class="dropspot">Platziere eine Instanz dieses Objekts in einem Raum und drücke die <strong>Play-Taste </strong><strong> <img></strong>und bewege dich dann mit dem linken Stick deines angeschlossenen Gamepads. Sie sollten etwas wie dies sehen:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Erweiterte 8-Wege-Bewegung</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">In diesem letzten Beispiel werden wir unsere 8-Wege-Bewegung <span class="notranslate">code</span> erneut betrachten und ein Problem angehen, das darin besteht, dass die diagonale Bewegung tatsächlich schneller ist als die Bewegung nach oben/unten/links/rechts. Das liegt einfach daran, dass man sich bei einer diagonalen Bewegung entlang der Hypotenuse eines rechtwinkligen Dreiecks bewegt, das durch die x/y-Bewegungswerte entsteht:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">Um zu verdeutlichen, was passiert, entfernen wir den ganzen Text und <span class="notranslate">sprites</span> und zeigen einfach die gleiche Bewegungslinie um 45° gedreht, so dass sie horizontal ist:</p>
    <p class="dropspot"><img alt="Animation Showing 4-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_1.gif" /></p>
    <p class="dropspot">Wie du sehen kannst, ist der Unterschied ziemlich offensichtlich, und wenn sich die Instanz mehr als 1 oder 2 Pixel pro Schritt bewegt, dann wird es sehr auffällig, dass die diagonale Bewegung <em>viel </em>schneller ist! Wie können wir dies also begrenzen? Es gibt mehrere Möglichkeiten, dies zu tun, aber wir werden uns auf eine davon konzentrieren, weil sie eine Reihe von Funktionen und Konzepten einführt, die dir später in deinen Spielen nützlich sein werden.</p>
    <p class="dropspot">Um dies zu bewerkstelligen, müssen wir die Eingabewerte der unabhängig voneinander gedrückten Tasten in<span class="glossextra">Variablen</span> speichern und diese dann überprüfen und entsprechend der gedrückten Tastenkombination bewegen. Hierfür benötigen Sie ein Objekt, dem ein <span class="notranslate">sprite</span> zugewiesen ist und dem Sie ein <strong>Step-Event</strong> mit den folgenden Aktionen oder Code zuweisen müssen:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_2.png" /></p>
    <p class="note"><span class="note">HINWEIS</span> Wir haben die visuellen Aktionen oben auf zwei Spalten aufgeteilt, um die Darstellung zu vereinfachen, aber im visuellen Editor werden sie fortlaufend angeordnet.</p>
    <p class="code">var _left = keyboard_check(vk_left);<br />
      var _right = keyboard_check(vk_right);<br />
      var _up = keyboard_check(vk_up);<br />
      var _down = keyboard_check(vk_down);<br />
      var _hspd = _right - _left;<br />
      var _vspd = _down - _up;</p>
    <p class="dropspot">Wir müssen noch etwas <span class="notranslate">code</span> hinzufügen, um uns tatsächlich zu bewegen, aber bevor wir das tun, wollen wir das ein wenig erklären. Wir wollen links/rechts/oben/unten in äquivalente horizontale und vertikale Geschwindigkeitswerte umwandeln, so dass wir den Wert jeder Taste erhalten und dann einige grundlegende Mathematik auf sie tun, um die Geschwindigkeitswerte zu erhalten. Das funktioniert, weil die Prüfaktion oder -funktion &quot;1&quot; zurückgibt, wenn eine Taste gedrückt wird, und wenn sie <em>nicht </em>gedrückt wird, gibt die Funktion 0 zurück. Wenn also - zum Beispiel - rechts gedrückt wird, hast du &quot;1 - 0 = 1&quot; für die &quot; <span class="inline">_hspd</span>&quot;, und wenn links gedrückt wird, hast du &quot;0 - 1 = -1&quot; für die &quot; <span class="inline">_hspd</span>&quot; (und wenn beide gedrückt werden, ist es &quot;1 - 1 = 0&quot;, also wird sich die Instanz nicht bewegen). Erinnere dich, in einem <span data-keyref="GameMaker Name">GameMaker-Raum</span> addieren wir zur Position <span class="inline">x </span>, um uns nach rechts zu bewegen, und subtrahieren, um uns nach links zu bewegen. Daher gibt uns <span class="notranslate">code</span> einen positiven oder negativen Wert, den wir addieren oder subtrahieren können, um uns je nach Tastatureingabe horizontal oder vertikal zu bewegen.</p>
    <p class="dropspot">Jetzt können wir die <span class="notranslate">code</span> hinzufügen, die die Instanz tatsächlich bewegt, also - immer noch im <strong>Step Event</strong> und nach der obigen <span class="notranslate">code</span> - fügen Sie dies hinzu:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if (_hspd != 0 || _vspd != 0)<br />
      {<br />
          var _spd = 4;<br />
          var _dir = point_direction(0, 0, _hspd, _vspd);<br />
          var _xadd = lengthdir_x(_spd, _dir);<br />
          var _yadd = lengthdir_y(_spd, _dir);<br />
          x = x + _xadd;<br />
          y = y + _yadd;<br />
      }</p>
    <p class="dropspot">Die obige <span class="notranslate">code</span> prüft zunächst, ob einer der beiden <a class="glossterm" data-glossterm="Ausdruck" href="#">Ausdrücke</a>wahr ist, d.h. ob die Variablen für die horizontale oder vertikale Geschwindigkeit ungleich 0 sind. Beachten Sie, dass die Prüfung &quot; <span class="inline">if</span>&quot; <span class="notranslate">GML</span> das Symbol &quot; <span class="inline">||</span>&quot; verwendet. In der Programmierung bedeutet dies &quot; <span class="inline">or</span>&quot;, also - im Klartext - Sie prüfen</p>
    <p class="code">if the variable _hspd does not equal zero<br />
      <strong>or</strong><br />
      if the variable _vspd does not equal zero
    </p>
    <p class="dropspot">Sie können auf diese Weise mehrere Ausdrücke in &quot; <span class="inline">if</span>&quot; Checks aneinanderreihen, und es gibt mehrere verschiedene Möglichkeiten, wie diese Ausdrücke ausgewertet werden können (weitere Informationen finden Sie im Abschnitt über <strong>Ausdrücke</strong> <a href="../GameMaker_Language/GML_Overview/Expressions_And_Operators.htm">hier</a>).</p>
    <p class="dropspot">Der nächste Abschnitt von <span class="notranslate">code</span> speichert einen Wert für die aktuelle Bewegungsgeschwindigkeit in einer Variablen und ermittelt dann eine Richtung anhand der Werte <span class="inline">_hspd </span>und <span class="inline">_vspd </span>, die -1, 0 oder 1 sein können. Die Richtungsfunktion prüft von (0, 0) aus, da wir keine Raumkoordinaten verwenden, sondern eine Richtung von 0° bis 360° basierend auf den Variablenwerten auswerten wollen. Das folgende Diagramm veranschaulicht das Geschehen besser als der Versuch, es in Worten zu erklären:</p>
    <p class="dropspot"><img alt="Animation Showing 8-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_2.gif" /></p>
    <p class="note"><span class="note">HINWEIS</span> Die Richtung wird in <span data-keyref="GameMaker Name">GameMaker</span> <strong>gegen den Uhrzeigersinn</strong> berechnet, d.h. 0° und 360° sind nach rechts, 90° ist nach oben, 180° ist nach rechts und 270° ist nach unten.</p>
    <p class="dropspot">Schließlich verwenden wir die <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_x.htm"><span class="inline">lengthdir_x()</span></a> und <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_y.htm"><span class="inline">lengthdir_y()</span></a> Funktionen, um die Variable tatsächlich zu verschieben. Diese sind <strong> <a class="glossterm" data-glossterm="Vektor" href="#">Vektor</a>  </strong>Funktionen, die eine Länge (Entfernung) und eine Richtung annehmen und dann die neue Position auf der gegebenen Achse auf der Grundlage dieser Werte berechnen (siehe die Funktionsbeschreibungen für eine genauere Erklärung).</p>
    <p class="dropspot">Das ist eine Menge auf einmal, und machen Sie sich keine Sorgen, wenn Sie noch nicht alles verstanden haben! Das wirst du mit der Zeit! Alles, was jetzt noch zu tun ist, ist, eine Instanz dieses Objekts zu einem Raum hinzuzufügen und dann die <strong>Play-Taste </strong>zu drücken <strong> <img></strong>und du solltest eine seidenweiche 8-Wege-Bewegung erhalten, ohne eines der Probleme, die mit der diagonalen Bewegung verbunden sind:</p>
    <p class="dropspot"><img alt="Getting Gamepad ID Using DnD" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_3_1.png" /></p>
  </div>
  <p> </p>
  <p>Wir hoffen, dass Sie mit diesen Beispielen - und den vorangegangenen Beispielen zum Zeichnen - genug Verständnis haben, um Ihre eigenen Projekte zu erstellen! Auf der letzten Seite dieser Kurzanleitung finden Sie eine Zusammenfassung des Gelernten sowie Links zu weiteren Lernmaterialien.</p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Zurück: <a href="../Content.htm">Index</a></div>
        <div style="float:right">Nächste: <a href="Summary.htm">Zusammenfassung</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Alle Rechte vorbehalten</span></h5>
  </div>
  <!-- KEYWORDS
Movement
Controls
Movement and Controls
Movement Examples
Controls Examples
-->
  <!-- TAGS
qs_movement_controls
-->
</body>
</html>