<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Zeichnung</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code to show people how things are drawn." />
  <meta name="rh-index-keywords" content="Quick Start - Drawing" />
  <meta name="search-keywords" content="drawing,draw event,GUI layer" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Zeichnung</h1>
  <p>Dieser Abschnitt (und der folgende Abschnitt über <a href="Movement_And_Controls.htm">Bewegung und Steuerung</a>) zielt darauf ab, Ihnen praktische Beispiele für <span class="notranslate">GML</span> oder <span class="notranslate">GML</span> Visual zu geben, damit Sie so schnell wie möglich mit der Entwicklung Ihrer ersten Spielprojekte beginnen können. Wir werden nicht zu sehr in die Tiefe gehen, da wir möchten, dass Sie so schnell wie möglich mit der Entwicklung beginnen können. Wir möchten Sie daher ermutigen, alle Links zu erkunden und die Suchfunktion des Handbuchs zu nutzen, um nach zusätzlichen Informationen zu suchen, wenn Sie sich nicht sicher sind.</p>
  <p>In diesem Abschnitt werden wir uns auf das einfache Zeichnen von Informationen auf dem Bildschirm konzentrieren, sowohl als Text als auch als Bild, und auch ein wenig mehr über die verschiedenen <strong>Draw-Ereignisse</strong> erklären, insbesondere das Hauptereignis <strong>Draw</strong> und das <strong>Draw GUI-Ereignis </strong>(beachten Sie, dass Sie in einigen der Beispiele andere Ereignisse hinzufügen müssen, aber wir werden diese erklären, wenn wir zu ihnen kommen).</p>
  <p><img alt="The Draw Events" class="center" src="../assets/Images/QS_Guide/QS_DrawEvents.png" /></p>
  <p>Bevor Sie weitermachen, sollten Sie auf der <a href="../Introduction/The_Start_Page.htm">Startseite</a> ein neues Projekt erstellen (entweder <span class="notranslate">GML</span> oder <span class="notranslate">GML</span> Visual) und einige <span class="notranslate">sprites</span> sowie ein oder zwei Objekte hinzufügen (oder erstellen), da wir Ihnen einige <span class="notranslate">code</span> geben werden, die Sie damit testen können. Sogar ein weißes Quadrat wird für den Moment als <span class="notranslate">sprite</span> für unser Objekt funktionieren!</p>
  <p>Wie im Abschnitt über <a href="Objects_And_Instances.htm">Objekte und Instanzen</a> erwähnt, zeichnet <span data-keyref="GameMaker Name">GameMaker</span> standardmäßig, wenn Sie dem Objekt kein Draw-Ereignis hinzufügen, d. h., wenn dem Objekt eine <span class="notranslate">sprite</span> zugewiesen ist, wird diese <span class="notranslate">sprite</span> gezeichnet, einschließlich aller hinzugefügten Transformationen. Was meinen wir mit Transformationen? Nun, jedes Objekt hat eine Reihe von eingebauten<span class="glossextra">Variablen</span>, die steuern, wie eine Instanz des Objekts seine <span class="notranslate">sprite</span> zeichnet, wenn es standardmäßig gezeichnet wird, und Sie können diese Variablen ändern, während das Spiel läuft, um die Art und Weise zu ändern, wie die <span class="notranslate">sprite</span> gezeichnet wird.</p>
  <p class="note"><strong>HINWEIS</strong>: Eine Liste aller eingebauten Variablen, die für die Umwandlung von Instanzen verwendet werden können, finden Sie <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/Sprite_Instance_Variables.htm">hier</a> <span class="notranslate">sprites</span>. <span class="notranslate">GML</span> Visual-Benutzer haben einige spezielle Aktionen, die diese Variablen beeinflussen, die Sie <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Drawing_Actions.htm">hier</a> finden, und Sie können auch die eigentlichen Variablen selbst zusammen mit den Aktionen <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Get_Instance_Variable.htm">Instanzvariable holen</a> und <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Set_Instance_Variable.htm">Instanzvariable setzen</a> verwenden.</p>
  <p>Schauen wir uns einige Beispiele an:</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Ändern von Alpha (Transparenz)</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot">Der <strong>Alphawert </strong>steuert die Transparenz dessen, was gezeichnet wird, und in <span data-keyref="GameMaker Name">GameMaker</span> können Sie die eingebaute Variable <span class="inline">image_alpha</span> verwenden, um zu ändern, wie transparent das zugewiesene <span class="notranslate">sprite</span> ist. Um zu sehen, wie das funktioniert, öffnen (oder erstellen) Sie ein Objekt, weisen Sie ihm eine <span class="notranslate">sprite</span> zu und geben Sie dem Objekt dann ein <strong>Create Event</strong>. Fügen Sie im Erstellungsereignis einfach die folgende <span class="notranslate">GML</span> Visual oder GML hinzu:</p>
    <p class="dropspot"><img alt="GML VisualDraw Example For Transparency" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_1.png" /></p>
    <p class="code">var _val = random(1);
      <br />
      image_alpha = _val;
    </p>
    <p class="dropspot">Der Alphawert eines Bildes wird als Wert zwischen 0 und 1 berechnet, wobei 0 für vollständig transparent und 1 für vollständig undurchsichtig steht (standardmäßig ist er auf 1 gesetzt). In diesem Beispiel geht es also nur darum, den Alphawert des Bildes auf einen zufälligen Dezimalwert zwischen 0 und 1 zu setzen. Platzieren Sie einige Instanzen dieses Objekts in einem Raum und klicken Sie dann auf die Schaltfläche " <strong>Abspielen </strong>" <img> oben auf der Seite <span class="notranslate">IDE</span>.</p>
    <p class="dropspot">Sie sollten sehen, dass jede Instanz des Objekts seine <span class="notranslate">sprite</span> mit einer anderen Transparenz zeichnet, z. B.:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">Ändern der Farbmischung (Tönung)</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot">Wenn Ihr Objekt standardmäßig ein <span class="notranslate">sprite</span> zeichnet, wird dieses <span class="notranslate">sprite</span> tatsächlich mit einer Farbe <strong>überlagert </strong>(oder <strong>getönt</strong>) gezeichnet, und dieser Farbwert wird in der eingebauten Variablen <span class="inline">image_blend</span> gespeichert. Standardmäßig ist diese Farbe weiß, was im Wesentlichen bedeutet, dass dem <span class="notranslate">sprite</span> keine Farbe hinzugefügt wird, wenn es auf dem Bildschirm angezeigt wird. Sie können jedoch andere Farben verwenden, um spezielle Effekte zu erzielen, z. B. Rot, um anzuzeigen, dass die Instanz Schaden genommen hat.</p>
    <p class="dropspot">In diesem Beispiel sollen verschiedene Farben mit der <span class="notranslate">sprite</span> überblendet werden, während eine Taste gedrückt und gehalten wird. Dazu müssen Sie ein Objekt öffnen (oder erstellen), ihm eine <span class="notranslate">sprite</span> zuweisen und dann dem Objekt ein <strong>Key Down &lt;Space&gt; Event</strong> geben.</p>
    <p class="dropspot"><img alt="Example Of Sprites Drawn With Different Alpha Values" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_1.png" /></p>
    <p class="dropspot">Fügen Sie in diesem Key Down Event das folgende <span class="notranslate">GML</span> Visual oder GML hinzu:</p>
    <p class="dropspot"><img alt="Add Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png" /></p>
    <p class="code">var _col = choose(c_red, c_green, c_blue, c_yellow, c_fuchsia, c_orange);
      <br />
      image_blend = _col;
    </p>
    <p class="dropspot">Platzieren Sie einige Instanzen dieses Objekts in einem Raum und klicken Sie dann auf die Schaltfläche "Abspielen" <img> oben auf <span class="notranslate">IDE</span> und testen Sie, ob Sie die <em>Leertaste </em>gedrückt halten und wieder loslassen können. Sie sollten sehen, dass jede Instanz ihre Farbe schnell ändert, während die Taste gedrückt gehalten wird, und dass sie aufhört, sich zu ändern, wenn sie losgelassen wird:</p>
    <p class="dropspot"><img alt="GML VisualExample Using Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_2.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Skala ändern</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Eine weitere Eigenschaft, die wir für unsere <span class="notranslate">sprite</span> ändern können, ist der <strong>Skalierungswert </strong>, der es uns erlaubt, sie größer oder kleiner zu zeichnen, wann immer wir wollen. Die Skalierung wird unabhängig voneinander entlang der X- und Y-Achse durch zwei getrennte Variablen berechnet, die Variable <span class="inline">image_xscale</span> und die Variable <span class="inline">image_yscale</span>. Standardmäßig sind diese auf 1 gesetzt und wirken wie <strong>Multiplikatoren</strong>, so dass ein Wert von 0,5 die halbe Skala und ein Wert von 2 die doppelte Skala bedeuten würde.</p>
    <p class="note"><strong>WICHTIG! </strong>Wenn Sie den zugewiesenen Maßstab von <span class="notranslate">sprite</span> mithilfe dieser Variablen ändern <strong>, wird auch die Größe des Begrenzungsrahmens entsprechend angepasst</strong>, was bedeutet, dass der Kollisionserkennungsbereich für <span class="notranslate">sprite</span> ebenfalls skaliert wird.</p>
    <p class="dropspot">In diesem Beispiel werden wir einige einfache mathematische Methoden verwenden, um eine Instanz von <span class="notranslate">sprite</span> in einem <span class="notranslate">loop</span> zu skalieren. Öffnen (oder erstellen) Sie zunächst ein Objekt, weisen Sie ihm ein <span class="notranslate">sprite</span> zu und geben Sie dem Objekt ein <strong>Create Event</strong>. In diesem Ereignis fügen Sie Folgendes hinzu:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">timer = 0;</p>
    <p class="dropspot">Fügen Sie dem Objekt nun ein <strong>Step Event</strong> hinzu:</p>
    <p class="dropspot"><img alt="Example Showing Colour Blending" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_2.png" /></p>
    <p class="code">timer = timer + 1;
      <br />
      var _val = dsin(timer);
      <br />
      image_xscale = 1 + _val;
      <br />
      image_yscale = 1 + _val;
    </p>
    <p class="dropspot">Hier verwenden wir die Mathefunktion <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/dsin.htm"><span class="inline">dsin()</span></a> um mit Hilfe der Timer-Variablen einen Wert zwischen -1 und 1 zu erzeugen und diesen dann auf die Skalenvariablen anzuwenden. Nachdem Sie einige Instanzen in einem Raum platziert und die <strong>Play-Taste </strong> <img> gedrückt haben, sollten Sie sehen, wie die Instanzen von einer Skala von 0 bis zu einer Skala von 2 und wieder zurück skalieren.</p>
    <p class="dropspot"><img alt="GML VisualSet Variable Example" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_1.png" /></p>
    <p class="dropspot">Eine letzte Sache... ändern Sie den Abschnitt &quot; <span class="inline">image_yscale</span>&quot; in &quot; <span class="inline">1 - _val</span>&quot; und sehen Sie, was passiert!</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Die obigen Beispiele zeigen nur einige der vielen Möglichkeiten, wie Sie das Objekt <span class="notranslate">sprite</span> manipulieren können, wenn <span data-keyref="GameMaker Name">GameMaker</span> standardmäßig zeichnet. In solchen Fällen müssen Sie das <strong>Draw-Ereignis</strong> verwenden, um <span data-keyref="GameMaker Name">GameMaker</span> explizit mitzuteilen, was gezeichnet werden soll, was wir in den folgenden Beispielen tun werden.</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Zeichnen von zwei (oder mehr) <span class="notranslate">Sprites</span> zusammen</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">Für dieses Beispiel benötigen Sie zwei <span class="notranslate">sprites</span> und ein Objekt. Nennen Sie die <span class="notranslate">sprites</span> &quot; <span class="inline">spr_One</span>&quot; und &quot; <span class="inline">spr_Two</span>&quot;, und setzen Sie dann den Ursprung von &quot; <span class="inline">spr_One</span>&quot; in die Mitte und von &quot; <span class="inline">spr_Two</span>&quot; in die linke Mitte:</p>
    <p class="dropspot"><img>Weisen Sie das erste <span class="notranslate">sprite</span> (&quot; <span class="inline">spr_One</span>&quot; mit dem zentralen Ursprung) dem von Ihnen erstellten Objekt zu und fügen Sie dann ein <strong>Ereignis erstellen</strong>hinzu. Fügen Sie in das Ereignis "Create Event" das folgende <span class="notranslate">GML</span> Visual oder GML ein:</p>
    <p class="dropspot"><img alt="GML VisualActions To Change Sprite Scale" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_2.png" /></p>
    <p class="code">draw_angle = 0;</p>
    <p class="dropspot">Wir werden diese Variable verwenden, um &quot; <span class="inline">spr_Two</span>&quot; im Laufe der Zeit zu drehen und sie über der <span class="notranslate">sprite</span> zu zeichnen, die dem Objekt zugewiesen ist (&quot; <span class="inline">spr_One</span>&quot;). Dazu müssen wir dem Objekt ein <strong>Draw Event </strong>hinzufügen. Damit teilen wir <span data-keyref="GameMaker Name">GameMaker</span> mit, dass wir übernehmen wollen, was die Instanz zeichnet, was bedeutet, dass unser <span class="notranslate">code</span> einen Aufruf der <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_self.htm"><span class="inline">draw_self()</span></a> Funktion oder <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Draw_Self.htm"><strong>Selbst zeichnen</strong></a> Aktion enthält. Diese Aktion repliziert einfach, was das Objekt tut, wenn kein Draw-Ereignis vorhanden ist und es standardmäßig die zugewiesene <span class="notranslate">sprite</span> zeichnet. Wir zeichnen dann das zweite <span class="notranslate">sprite</span>, das wir als Overlay <span class="notranslate">sprite</span> verwenden wollen, das sich dreht. Das <span class="notranslate">GML</span> Visual und <span class="notranslate">GML</span> sieht wie folgt aus:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_angle = draw_angle + 0.5;
      <br />
      draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    </p>
    <p class="dropspot">Füge eine Anzahl von Instanzen des Objekts in den Raum-Editor ein und drücke dann den <strong>Play-Button </strong> <img> oben in der <a class="glossterm" data-glossterm="IDE" href="#">IDE</a>. Wenn alles richtig gelaufen ist, sollten Sie jetzt etwas wie dieses sehen:</p>
    <p class="dropspot"><img class="center" src="../assets/Images/QS_Guide/QS_DrawExample_3.gif" title="Animation Showing Sprite Scaling" /></p>
    <p class="dropspot">Bevor wir uns von diesem Beispiel verabschieden, wollen wir es noch ein wenig abwandeln. Anstatt &quot; <span class="inline">spr_Two</span>&quot; einfach zu drehen, werden wir es in Richtung der Mausposition zeigen lassen. Dazu müssen wir das Draw Event <span class="notranslate">GML</span> Visual oder <span class="notranslate">GML</span> so ändern, dass es wie folgt aussieht:</p>
    <p class="dropspot"><img alt="Show Origins For Sprites" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_1.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_angle = point_direction(x, y, mouse_x, mouse_y);
      <br />
      draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    </p>
    <p class="dropspot">Führen Sie das Projekt erneut aus, und dieses Mal werden Sie etwas ganz anderes sehen!</p>
    <p class="dropspot"><img>Die <span class="notranslate">sprite</span> zeigt jetzt in Richtung der Maus, egal wohin Sie sie bewegen! Wie Sie sehen, ist das Überlagern von <span class="notranslate">sprites</span> eine großartige Möglichkeit, einem Objekt Details hinzuzufügen oder etwas unabhängig von der dem Objekt zugewiesenen &quot;Basis&quot; <span class="notranslate">sprite</span> zu bewegen, und es ist ein leistungsfähiges Werkzeug, das Sie wahrscheinlich häufig in Ihren eigenen Projekten verwenden werden.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down4" href="#">Andere Dinge als Sprites zeichnen</a></p>
  <div class="droptext" data-targetname="drop_down4">
    <p class="dropspot">Sie können im Draw Event auch andere Dinge als <span class="notranslate">sprites</span> zeichnen, wie Text oder Formen. In diesem Beispiel werden wir die Funktion <span class="notranslate">GML</span> Visual oder <span class="notranslate">GML</span> <span class="inline">draw_self()</span> verwenden, um das Objekt <span class="notranslate">sprite</span> zu zeichnen, aber wir werden auch einige andere Dinge zeichnen, beginnend mit etwas <strong>Text</strong>. Für dieses Beispiel benötigen Sie eine <span class="notranslate">sprite</span> und ein Objekt (dem die <span class="notranslate">sprite</span> zugewiesen ist). Fügen Sie im Objekt zunächst ein <strong>Create Event</strong> mit diesem <span class="notranslate">GML</span> Visual oder GML hinzu:</p>
    <p class="dropspot"><img alt="Set Draw Angle Variable In DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_1.png" /></p>
    <p class="code">name = choose(&quot;Fred&quot;, &quot;Jonas&quot;, &quot;Sharon&quot;, &quot;Kate&quot;, &quot;Frank&quot;, &quot;John&quot;, &quot;Monica&quot;, &quot;Amanda&quot;);
      <br />
      number = irandom(100);
    </p>
    <p class="dropspot">Damit wird <span data-keyref="GameMaker Name">GameMaker</span> angewiesen, einen der aufgelisteten Namen auszuwählen und ihn einer Variablen zuzuweisen sowie eine Zufallszahl von 0 bis 100 für jede Instanz des Objekts zu erzeugen. Da wir diese Werte auf den Bildschirm zeichnen wollen, müssen Sie jetzt ein <strong>Draw-Ereignis</strong> hinzufügen und darin das folgende <span class="notranslate">GML</span> Visual oder GML einfügen:</p>
    <p class="dropspot"><img alt="Draw Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_2.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_set_halign(fa_center);
      <br />
      draw_text(x, y + 32, &quot;My name is &quot; + name);
      <br />
      draw_text(x, y + 48, &quot;My number is &quot; + string(number));
    </p>
    <p class="dropspot">Sie werden in der obigen <span class="notranslate">code</span> feststellen, dass wir die <a href="../GameMaker_Language/GML_Reference/Strings/string.htm"><span class="inline">string()</span></a> Funktion oder <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Data_Types/Number_To_String.htm"><strong>Zahl in Zeichenkette</strong></a> auf die Variable &quot;Zahl&quot; anwenden, die wir zeichnen wollen. Der Grund dafür ist, dass jeder Text aus <em>Zeichen</em> und nicht aus Werten bestehen muss. Daher müssen wir diese Funktion/Aktion verwenden, um den Zahlenwert in die Zeichen umzuwandeln, die wir zeichnen wollen. In diesem Fall nehmen wir die Zufallszahl, die wir erzeugt haben, und wandeln sie in eine Zeichenkette um, die gezeichnet werden kann. Beachte auch, dass wir die <strong>Textausrichtung</strong> festlegen. Damit wird dem <span data-keyref="GameMaker Name">GameMaker</span> einfach mitgeteilt, wo er mit dem Zeichnen des Textes in Bezug auf die angegebene Position beginnen soll, und in diesem Fall möchten wir, dass der Text entlang der X-Achse zentriert wird.</p>
    <p class="dropspot">Fügen Sie eine Reihe von Instanzen des Objekts in den Raumeditor ein und klicken Sie dann auf die Schaltfläche "Play" <img> oben auf <span class="notranslate">IDE</span>. Sie sollten etwas wie dieses sehen:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">In allen bisherigen Beispielen haben wir die <span class="notranslate">sprite</span> gezeichnet, die der Instanz zugewiesen ist, aber das muss nicht immer der Fall sein. <strong>Sie können</strong> im Draw-Ereignis <strong>alles zeichnen, was Sie wollen</strong>, unabhängig von dem zugewiesenen <span class="notranslate">sprite</span>. Zur Veranschaulichung dieses Punktes ändern wir die <span class="notranslate">code</span>, die wir derzeit haben, indem wir den Aufruf <span class="inline">draw_self()</span> entfernen und durch eine Funktion zum Zeichnen einer farbigen Ellipse ersetzen, etwa so:</p>
    <p class="dropspot"><img alt="Animation Drawing Two Sprites Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_2.gif" /></p>
    <p class="code">draw_ellipse_colour(x - 50, y - 32, x + 50, y + 32, c_fuchsia, c_lime, false);
      <br />
      draw_set_halign(fa_center);
      <br />
      draw_text(x, y + 32, &quot;My name is &quot; + name);
      <br />
      draw_text(x, y + 48, &quot;My number is &quot; + string(number));
    </p>
    <p class="dropspot">Führen Sie das Projekt erneut aus und Sie sollten folgendes sehen:</p>
    <p class="dropspot"><img alt="Edited Draw Code For Drawing Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_3.png" /></p>
    <p class="dropspot">Eine wichtige Sache, die dabei zu beachten ist, ist, dass, auch wenn wir die zugewiesene <span class="notranslate">sprite</span> nicht zeichnen, <strong>sie trotzdem für die Kollisionserkennung verwendet</strong> wird. Während du also eine Sache zeichnest, werden Kollisionen immer noch anhand der zugewiesenen <span class="notranslate">sprite</span> berechnet, als ob sie zusammen mit der Instanz im Raum platziert wäre, auch wenn sie nicht sichtbar ist. Das ist eigentlich ziemlich praktisch, da es bedeutet, dass du verschiedene <span class="notranslate">sprites</span> zeichnen kannst, aber eine einzige <strong>Kollisionsmaske</strong> basierend auf der zugewiesenen <span class="notranslate">sprite</span> beibehalten kannst. Beachten Sie auch, dass Sie immer noch die verschiedenen Transformationen wie X/Y-Skalierung anwenden können und Kollisionen auf der geänderten Größe basieren, auch wenn nichts gezeichnet wird, um dies zu zeigen.</p>
  </div>
  <p> </p>
  <p> </p>
  <h1>Die GUI-Schicht</h1>
  <p>Wir haben oben auf der Seite erwähnt, dass wir sowohl über das <strong>Draw GUI Event</strong> als auch über das Draw Event sprechen werden, also lassen Sie uns jetzt einen Blick darauf werfen. Das Draw GUI Event arbeitet mit dem sogenannten <strong> <a class="glossterm" data-glossterm="GUI" href="#">GUI</a></strong> Layer, einer speziellen Zeichenebene mit fester Breite und Höhe, die über die Instanzen im Raum gezeichnet wird. Das Tolle an der GUI-Ebene ist, dass <em> sie sich nicht mit der Raumkamera mit</em>bewegt, so dass sie der ideale Ort ist, um statische GUI-Elemente hinzuzufügen, wie Spielstände, Gesundheitsleisten und andere Informationen, die dein Spiel benötigt, um dem Benutzer zu vermitteln. Weitere Informationen über die GUI-Ebene finden Sie im Abschnitt <a href="../The_Asset_Editors/Object_Properties/Draw_Events.htm">Draw Events</a> des Handbuchs.</p>
  <p class="note"><strong>HINWEIS</strong>: Räume können größer sein als der Bildschirm, so dass Sie große Ebenen haben, in denen sich der Spieler bewegen kann. Das bedeutet, dass Sie im Raum-Editor (oder in <span class="notranslate">code</span>) eine <strong>Kamera </strong>definieren müssen, die der Handlung Ihres Spiels folgt. Dies ist im Grunde eine Möglichkeit, einen festen Bereich des Bildschirms so einzurichten, dass verschiedene Teile des größeren Raums angezeigt werden, je nachdem, wo sich der Spieler im Raum befindet, und wird in vielen Spielen verwendet. Denken Sie nur daran, wie der Blick in klassischen Spielen wie Mario oder Zelda immer der Hauptfigur folgt. Das wird mit Kameras gemacht. Weitere Informationen finden Sie im Abschnitt <a href="../The_Asset_Editors/Room_Properties/Room_Properties.htm">Raumeigenschaften</a> im Abschnitt Raumeditor des Handbuchs.</p>
  <p>Die folgenden Beispiele werden alle das Ereignis " <strong>Draw GUI</strong> " verwenden, also müssen Sie ein Objekt erstellen und ihm dieses Ereignis hinzufügen. Beachten Sie, dass dem Objekt kein <span class="notranslate">sprite</span> zugewiesen werden muss, da wir nichts zeichnen wollen und es auch keine Kollisionen erkennen muss. Objekte wie dieses, die nur zum Zeichnen von Dingen oder zur Steuerung bestimmter Aspekte des Spiels gedacht sind, werden oft als <strong>Controller-Objekte</strong> bezeichnet. Beachten Sie auch, dass wir für alle Beispiele dasselbe Objekt verwenden werden, daher empfehlen wir Ihnen, sie nacheinander durchzugehen (obwohl dies nicht unbedingt notwendig ist).</p>
  <p><img> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down5" href="#">Zeichnen von Text</a></p>
  <div class="droptext" data-targetname="drop_down5">
    <p class="dropspot">Beim Zeichnen auf der GUI-Ebene ist die linke obere Ecke die Ursprungsposition, nach rechts ist +X und nach unten ist +Y. Das macht die Positionierung von Text und Grafiken sehr einfach, wie Sie in diesem Beispiel sehen werden. Alles, was wir hier tun werden, ist einen Wert zu zeichnen, der den Punktestand des Spielers repräsentiert. Daher müssen wir in unserem Objekt ein <strong>Create-Event </strong>hinzufügen, um eine Variable zu initialisieren, die diesen Wert enthält:</p>
    <p class="dropspot"><img alt="Animation Drawing Two Sprites Pointing At Mouse" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_3.gif" /></p>
    <p class="code">player_score = 0;</p>
    <p class="dropspot">Wir wollen auch ein <strong>Keyboard Down &lt;Space&gt; Event</strong> zu dem Objekt hinzufügen, da wir das benutzen werden, um die Punktzahl jedes Mal zu erhöhen, wenn Sie die Space-Taste drücken.</p>
    <p class="dropspot"><img alt="Setting Variables Using DnD" class="center" height="506" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1_1.png" width="317" /></p>
    <p class="dropspot">In diesem Fall ist Folgendes hinzuzufügen:</p>
    <p class="dropspot"><img alt="Drawing Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1.png" /></p>
    <p class="code">var _val = irandom(100);
      <br />
      player_score = player_score + _val;
    </p>
    <p class="dropspot">Zum Schluss zeichnen wir den Punktestand im Ereignis Draw GUI wie folgt:</p>
    <p class="dropspot">In diesem Fall ist Folgendes hinzuzufügen:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">draw_set_halign(fa_left);
      <br />
      draw_set_colour(c_yellow);
      <br />
      draw_text(32, 32, &quot;SCORE:&quot;);
      <br />
      draw_set_colour(c_white);
      <br />
      var _str = string(player_score);
      <br />
      draw_text_transformed(32, 48, _str, 2, 2, 0);
    </p>
    <p class="dropspot">Sie werden feststellen, dass wir für die x/y-Position des zu zeichnenden Textes <a class="glossterm" data-glossterm="fest codiert" href="#">fest kodierte</a> (oder feste) Werte verwendet haben, da wir ihn nicht relativ zu einer Instanz benötigen, da wir auf der GUI-Ebene zeichnen. Wir haben auch die Funktion &quot;set color&quot; verwendet, um die Farbe des Textes zu ändern, sowie die Funktion &quot;transformed&quot;, um den aktuellen Punktestand größer zu machen, was veranschaulicht, wie Sie Textelemente in Ihren eigenen Spielen anpassen können.</p>
    <p class="dropspot">Fügen Sie nun ein einzelnes Exemplar dieses Objekts zu Ihrem Raum hinzu und drücken Sie dann die <strong>Play-Taste </strong> <img>. Wenn das Spiel läuft, drücken Sie die Taste <span class="inline">&lt;Space&gt;</span> und Sie sollten sehen, dass der Punktestand steigt.</p>
    <p class="dropspot"><img alt="Sprites Being Drawn Along With Text" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down6" href="#">Zeichnen von Sprites</a></p>
  <div class="droptext" data-targetname="drop_down6">
    <p class="dropspot">In diesem Beispiel werden wir die GUI-Ebene verwenden, um einige <span class="notranslate">sprites</span> zu zeichnen. Die naheliegendste Verwendung dafür ist das Zeichnen der Spielerleben, also machen wir genau das! Für dieses Beispiel benötigen Sie eine <span class="notranslate">sprite</span>, die etwa 64x64 Pixel groß sein sollte, die aber nicht dem Objekt zugewiesen werden sollte, da wir sie selbst zeichnen werden.</p>
    <p class="dropspot">Zunächst müssen wir dem Objekt im <strong>Create-Ereignis</strong> einige neue Variablen hinzufügen (wenn Sie das vorherige Beispiel durchgeführt haben, fügen Sie die folgenden Variablen unter den bereits vorhandenen Variablen hinzu):</p>
    <p class="dropspot"><img alt="Drawing Shapes Along With Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_2.png" /></p>
    <p class="code">player_lives = 3;
      <br />
      gui_w = display_get_gui_width();
    </p>
    <p class="dropspot">In diesem <span class="notranslate">code</span> initialisieren wir eine Variable für die Spielerleben, aber wir erstellen auch eine Variable, um die Breite der GUI-Ebene zu halten, damit wir die Dinge korrekt relativ zur rechten Seite des Bildschirms positionieren können. Wir könnten einfach einen Wert in <span class="notranslate">code</span> fest einprogrammieren und diesen verwenden, aber das würde bedeuten, dass wir, wenn wir später Änderungen an der Größe des Raumes vornehmen oder Kameras usw. hinzufügen, die <span class="notranslate">code</span> durchgehen und den Wert überall ändern müssten. Die Verwendung der <a href="../GameMaker_Language/GML_Reference/Cameras_And_Display/display_get_gui_width.htm"><span class="inline">display_get_gui_width()</span></a> Funktion bedeutet, dass wir uns keine Gedanken über zukünftige Änderungen dieser Art machen müssen, da <span class="notranslate">code</span> sich automatisch an die Größe der GUI-Ebene anpasst.</p>
    <p class="dropspot">Als Nächstes fügen wir dem Objekt ein <strong>Keyboard Pressed &lt;Enter&gt; Event</strong> hinzu, da wir damit jedes Mal, wenn die Enter-Taste gedrückt wird, die Anzahl der Leben ändern werden:</p>
    <p class="dropspot"><img alt="Example Of Drawing Shapes And Text Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_2.png" /></p>
    <p class="dropspot">In diesem Fall ist Folgendes hinzuzufügen:</p>
    <p class="dropspot"><img alt="Draw GUI Event In An Object" class="center" src="../assets/Images/QS_Guide/QS_DrawGUIObject.png" /></p>
    <p class="code">player_lives = player_lives - 1;
      <br />
      <br />
      if player_lives &lt; 0
      <br />
      {
      <br />
      player_lives = 3;
      <br />
      }
    </p>
    <p class="dropspot">Schließlich müssen wir die <span class="notranslate">sprites</span> auf den Bildschirm zeichnen. Dazu verwenden wir ein &quot; <span class="inline">for</span>&quot; <span class="notranslate">loop</span> (Informationen über <span class="notranslate">GML</span> <a href="../GameMaker_Language/GML_Overview/Language_Features/for.htm">hier</a> und für <span class="notranslate">GML</span> Visual <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Loops/For.htm">hier</a>), zusammen mit der GUI-Breitenvariable, um alles in der oberen rechten Ecke des Bildschirms zu positionieren. Fügen Sie dies also in das Draw Gui Event ein (nach allen anderen Aktionen, die es aus den vorherigen Beispielen haben kann):</p>
    <p class="dropspot"><img alt="Defining A Variable Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_1.png" /></p>
    <p class="code">for (var i = 0; i &lt; player_lives; i += 1)
      <br />
      {
      <br />
      var _xx = gui_w - 48 - (i * 70);
      <br />
      draw_sprite(spr_Heart, 0, _xx, 48);
      <br />
      }
    </p>
    <p class="dropspot">Wenn Sie noch keine Instanz dieses Objekts zu einem Raum hinzugefügt haben, fügen Sie es jetzt hinzu (nur eine!) und drücken Sie dann die <strong>Play-Taste </strong> <img>. Sobald das Spiel läuft, drücken Sie mehrmals die Taste <span class="inline">&lt;Enter&gt;</span>, um zu sehen, wie sich das Leben verändert.</p>
    <p class="dropspot"><img alt="Adding A Space Key Pressed Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png" /></p>
    <p class="dropspot">Bevor Sie dieses Beispiel verlassen, sollten Sie mit der Anzahl der Leben experimentieren und sehen, was passiert. Im Moment ist sie auf 3 eingestellt, aber ändern Sie das Erstellungsereignis und das Tastendruck-Ereignis, um den Wert auf 5 oder 10 einzustellen... wenn Sie alles richtig gemacht haben, dann sollte sich <span class="notranslate">code</span> anpassen und sie alle richtig zeichnen!</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down7" href="#">Zeichnung einer Gesundheitsleiste</a></p>
  <div class="droptext" data-targetname="drop_down7">
    <p class="dropspot">In diesem letzten Beispiel geht es um das Zeichnen einer Gesundheitsleiste auf der GUI-Ebene. Es gibt eine Reihe von Möglichkeiten, dies zu tun, aber <span data-keyref="GameMaker Name">GameMaker</span> hat eine eingebaute Funktion speziell für die Erstellung von Healthbars, so dass wir diese hier verwenden werden, obwohl Sie auch Ihre eigenen mit <span class="notranslate">sprites</span> oder Formen erstellen können. Um zu beginnen, müssen wir wie zuvor eine Variable initialisieren, die den Gesundheitswert enthält, also fügen Sie das folgende <span class="notranslate">GML</span> Visual oder <span class="notranslate">GML</span> in das <strong>Create-Event</strong> des Objekts ein (nach allen anderen <span class="notranslate">code</span>, die bereits vorhanden sein können):</p>
    <p class="dropspot"><img alt="GML VisualActions In The Space Key Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_2.png" /></p>
    <p class="code">player_health = 100;</p>
    <p class="dropspot">Wir wollen die Pfeiltasten verwenden, um den Gesundheitswert nach oben oder unten zu ändern, je nachdem, welche Pfeiltaste gedrückt wird, und wir könnten das tun, indem wir zwei <strong>Keyboard Pressed &lt;Pfeil&gt;-Ereignisse</strong> hinzufügen, aber es ist wahrscheinlich einfacher, ein <strong>Step-Ereignis</strong> und einige <span class="notranslate">code</span> zu verwenden, um die Tasten zu überprüfen, so gehen Sie vor und fügen Sie ein <strong>Step-Ereignis</strong> jetzt mit dem folgenden <span class="notranslate">GML</span> Visual oder GML:</p>
    <p class="dropspot"><img alt="Drawing Text To The GUI Layer Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_3.png" /></p>
    <p class="code">if keyboard_check(vk_up)<br />
      {<br />
          if (player_health &lt; 100) <br />
          {<br />
              player_health = player_health + 1;<br />
          }<br />
      }<br />
      <br />
      if (keyboard_check(vk_down)) <br />
      {<br />
          if (player_health &gt; 0) <br />
          {<br />
              player_health = player_health - 1;<br />
          }<br />
      }
    </p>
    <p class="dropspot">Wenn das erledigt ist, können wir uns daran machen, die Gesundheitsleiste zu zeichnen, was im Draw GUI-Ereignis geschieht, indem wir das Folgende hinzufügen (nach allem anderen, was bereits vorhanden ist):</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _xx = display_get_gui_width() / 2;<br />
      <br />
      draw_healthbar(_xx - 50, 24, _xx + 50, 40, player_health, c_black, c_red, c_lime, 0, true, true);
    </p>
    <p class="dropspot">Fügen Sie eine Instanz dieses Objekts in einen Raum ein, falls Sie das noch nicht getan haben (allerdings nur eine!), und drücken Sie dann die <strong>Play-Taste </strong> <img>. Sobald das Spiel läuft, drücken Sie mehrmals die Tasten <span class="inline">&lt;Up Arrow&gt;</span> und <span class="inline">&lt;Down Arrow&gt;</span>, um die Veränderung der Gesundheit zu sehen.</p>
    <p class="dropspot"><img alt="Animation Showing Text Being Drawn To The GUI Layer" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_6.gif" /></p>
  </div>
  <p> </p>
  <p>Wir hoffen, dass Sie nach diesen Beispielen etwas mehr Selbstvertrauen im Umgang mit dem <span data-keyref="GameMaker Name">GameMaker</span> haben und etwas besser verstehen, wie alles funktioniert. Im nächsten Abschnitt werden wir uns damit beschäftigen, wie man die Dinge, die man gezeichnet hat, dazu bringt, sich im Raum zu bewegen und Benutzereingaben zu akzeptieren - und darauf zu reagieren.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Zurück: <a href="../Content.htm">Index</a></div>
        <div style="float:right">Nächste: <a href="Movement_And_Controls.htm">Bewegung und Steuerung</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Alle Rechte vorbehalten</span></h5>
  </div>
  <!-- KEYWORDS
Drawing
Drawing Examples
Quick Start Drawing
-->
  <!-- TAGS
qs_drawing
-->
</body>
</html>